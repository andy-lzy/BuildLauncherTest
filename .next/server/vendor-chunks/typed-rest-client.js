/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/typed-rest-client";
exports.ids = ["vendor-chunks/typed-rest-client"];
exports.modules = {

/***/ "(rsc)/./node_modules/typed-rest-client/Handlers.js":
/*!****************************************************!*\
  !*** ./node_modules/typed-rest-client/Handlers.js ***!
  \****************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.PersonalAccessTokenCredentialHandler = exports.NtlmCredentialHandler = exports.BearerCredentialHandler = exports.BasicCredentialHandler = void 0;\nvar basiccreds_1 = __webpack_require__(/*! ./handlers/basiccreds */ \"(rsc)/./node_modules/typed-rest-client/handlers/basiccreds.js\");\nObject.defineProperty(exports, \"BasicCredentialHandler\", ({ enumerable: true, get: function () { return basiccreds_1.BasicCredentialHandler; } }));\nvar bearertoken_1 = __webpack_require__(/*! ./handlers/bearertoken */ \"(rsc)/./node_modules/typed-rest-client/handlers/bearertoken.js\");\nObject.defineProperty(exports, \"BearerCredentialHandler\", ({ enumerable: true, get: function () { return bearertoken_1.BearerCredentialHandler; } }));\nvar ntlm_1 = __webpack_require__(/*! ./handlers/ntlm */ \"(rsc)/./node_modules/typed-rest-client/handlers/ntlm.js\");\nObject.defineProperty(exports, \"NtlmCredentialHandler\", ({ enumerable: true, get: function () { return ntlm_1.NtlmCredentialHandler; } }));\nvar personalaccesstoken_1 = __webpack_require__(/*! ./handlers/personalaccesstoken */ \"(rsc)/./node_modules/typed-rest-client/handlers/personalaccesstoken.js\");\nObject.defineProperty(exports, \"PersonalAccessTokenCredentialHandler\", ({ enumerable: true, get: function () { return personalaccesstoken_1.PersonalAccessTokenCredentialHandler; } }));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvdHlwZWQtcmVzdC1jbGllbnQvSGFuZGxlcnMuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsNENBQTRDLEdBQUcsNkJBQTZCLEdBQUcsK0JBQStCLEdBQUcsOEJBQThCO0FBQy9JLG1CQUFtQixtQkFBTyxDQUFDLDRGQUF1QjtBQUNsRCwwREFBeUQsRUFBRSxxQ0FBcUMsK0NBQStDLEVBQUM7QUFDaEosb0JBQW9CLG1CQUFPLENBQUMsOEZBQXdCO0FBQ3BELDJEQUEwRCxFQUFFLHFDQUFxQyxpREFBaUQsRUFBQztBQUNuSixhQUFhLG1CQUFPLENBQUMsZ0ZBQWlCO0FBQ3RDLHlEQUF3RCxFQUFFLHFDQUFxQyx3Q0FBd0MsRUFBQztBQUN4SSw0QkFBNEIsbUJBQU8sQ0FBQyw4R0FBZ0M7QUFDcEUsd0VBQXVFLEVBQUUscUNBQXFDLHNFQUFzRSxFQUFDIiwic291cmNlcyI6WyJDOlxcUHJvamVjdHNcXEJ1aWxkTGF1bmNoZXJUZXN0XFxub2RlX21vZHVsZXNcXHR5cGVkLXJlc3QtY2xpZW50XFxIYW5kbGVycy5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuUGVyc29uYWxBY2Nlc3NUb2tlbkNyZWRlbnRpYWxIYW5kbGVyID0gZXhwb3J0cy5OdGxtQ3JlZGVudGlhbEhhbmRsZXIgPSBleHBvcnRzLkJlYXJlckNyZWRlbnRpYWxIYW5kbGVyID0gZXhwb3J0cy5CYXNpY0NyZWRlbnRpYWxIYW5kbGVyID0gdm9pZCAwO1xudmFyIGJhc2ljY3JlZHNfMSA9IHJlcXVpcmUoXCIuL2hhbmRsZXJzL2Jhc2ljY3JlZHNcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJCYXNpY0NyZWRlbnRpYWxIYW5kbGVyXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBiYXNpY2NyZWRzXzEuQmFzaWNDcmVkZW50aWFsSGFuZGxlcjsgfSB9KTtcbnZhciBiZWFyZXJ0b2tlbl8xID0gcmVxdWlyZShcIi4vaGFuZGxlcnMvYmVhcmVydG9rZW5cIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJCZWFyZXJDcmVkZW50aWFsSGFuZGxlclwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gYmVhcmVydG9rZW5fMS5CZWFyZXJDcmVkZW50aWFsSGFuZGxlcjsgfSB9KTtcbnZhciBudGxtXzEgPSByZXF1aXJlKFwiLi9oYW5kbGVycy9udGxtXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiTnRsbUNyZWRlbnRpYWxIYW5kbGVyXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBudGxtXzEuTnRsbUNyZWRlbnRpYWxIYW5kbGVyOyB9IH0pO1xudmFyIHBlcnNvbmFsYWNjZXNzdG9rZW5fMSA9IHJlcXVpcmUoXCIuL2hhbmRsZXJzL3BlcnNvbmFsYWNjZXNzdG9rZW5cIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJQZXJzb25hbEFjY2Vzc1Rva2VuQ3JlZGVudGlhbEhhbmRsZXJcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHBlcnNvbmFsYWNjZXNzdG9rZW5fMS5QZXJzb25hbEFjY2Vzc1Rva2VuQ3JlZGVudGlhbEhhbmRsZXI7IH0gfSk7XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/typed-rest-client/Handlers.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/typed-rest-client/HttpClient.js":
/*!******************************************************!*\
  !*** ./node_modules/typed-rest-client/HttpClient.js ***!
  \******************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\n// Copyright (c) Microsoft. All rights reserved.\n// Licensed under the MIT license. See LICENSE file in the project root for full license information.\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.HttpClient = exports.HttpClientResponse = exports.HttpCodes = void 0;\nexports.isHttps = isHttps;\nconst url = __webpack_require__(/*! url */ \"url\");\nconst http = __webpack_require__(/*! http */ \"http\");\nconst https = __webpack_require__(/*! https */ \"https\");\nconst util = __webpack_require__(/*! ./Util */ \"(rsc)/./node_modules/typed-rest-client/Util.js\");\nlet fs;\nlet tunnel;\nvar HttpCodes;\n(function (HttpCodes) {\n    HttpCodes[HttpCodes[\"OK\"] = 200] = \"OK\";\n    HttpCodes[HttpCodes[\"MultipleChoices\"] = 300] = \"MultipleChoices\";\n    HttpCodes[HttpCodes[\"MovedPermanently\"] = 301] = \"MovedPermanently\";\n    HttpCodes[HttpCodes[\"ResourceMoved\"] = 302] = \"ResourceMoved\";\n    HttpCodes[HttpCodes[\"SeeOther\"] = 303] = \"SeeOther\";\n    HttpCodes[HttpCodes[\"NotModified\"] = 304] = \"NotModified\";\n    HttpCodes[HttpCodes[\"UseProxy\"] = 305] = \"UseProxy\";\n    HttpCodes[HttpCodes[\"SwitchProxy\"] = 306] = \"SwitchProxy\";\n    HttpCodes[HttpCodes[\"TemporaryRedirect\"] = 307] = \"TemporaryRedirect\";\n    HttpCodes[HttpCodes[\"PermanentRedirect\"] = 308] = \"PermanentRedirect\";\n    HttpCodes[HttpCodes[\"BadRequest\"] = 400] = \"BadRequest\";\n    HttpCodes[HttpCodes[\"Unauthorized\"] = 401] = \"Unauthorized\";\n    HttpCodes[HttpCodes[\"PaymentRequired\"] = 402] = \"PaymentRequired\";\n    HttpCodes[HttpCodes[\"Forbidden\"] = 403] = \"Forbidden\";\n    HttpCodes[HttpCodes[\"NotFound\"] = 404] = \"NotFound\";\n    HttpCodes[HttpCodes[\"MethodNotAllowed\"] = 405] = \"MethodNotAllowed\";\n    HttpCodes[HttpCodes[\"NotAcceptable\"] = 406] = \"NotAcceptable\";\n    HttpCodes[HttpCodes[\"ProxyAuthenticationRequired\"] = 407] = \"ProxyAuthenticationRequired\";\n    HttpCodes[HttpCodes[\"RequestTimeout\"] = 408] = \"RequestTimeout\";\n    HttpCodes[HttpCodes[\"Conflict\"] = 409] = \"Conflict\";\n    HttpCodes[HttpCodes[\"Gone\"] = 410] = \"Gone\";\n    HttpCodes[HttpCodes[\"TooManyRequests\"] = 429] = \"TooManyRequests\";\n    HttpCodes[HttpCodes[\"InternalServerError\"] = 500] = \"InternalServerError\";\n    HttpCodes[HttpCodes[\"NotImplemented\"] = 501] = \"NotImplemented\";\n    HttpCodes[HttpCodes[\"BadGateway\"] = 502] = \"BadGateway\";\n    HttpCodes[HttpCodes[\"ServiceUnavailable\"] = 503] = \"ServiceUnavailable\";\n    HttpCodes[HttpCodes[\"GatewayTimeout\"] = 504] = \"GatewayTimeout\";\n})(HttpCodes || (exports.HttpCodes = HttpCodes = {}));\nconst HttpRedirectCodes = [HttpCodes.MovedPermanently, HttpCodes.ResourceMoved, HttpCodes.SeeOther, HttpCodes.TemporaryRedirect, HttpCodes.PermanentRedirect];\nconst HttpResponseRetryCodes = [HttpCodes.BadGateway, HttpCodes.ServiceUnavailable, HttpCodes.GatewayTimeout];\nconst NetworkRetryErrors = ['ECONNRESET', 'ENOTFOUND', 'ESOCKETTIMEDOUT', 'ETIMEDOUT', 'ECONNREFUSED', 'EHOSTUNREACH'];\nconst RetryableHttpVerbs = ['OPTIONS', 'GET', 'DELETE', 'HEAD'];\nconst ExponentialBackoffCeiling = 10;\nconst ExponentialBackoffTimeSlice = 5;\nclass HttpClientResponse {\n    constructor(message) {\n        this.message = message;\n    }\n    readBody() {\n        return new Promise((resolve, reject) => __awaiter(this, void 0, void 0, function* () {\n            const chunks = [];\n            const encodingCharset = util.obtainContentCharset(this);\n            // Extract Encoding from header: 'content-encoding'\n            // Match `gzip`, `gzip, deflate` variations of GZIP encoding\n            const contentEncoding = this.message.headers['content-encoding'] || '';\n            const isGzippedEncoded = new RegExp('(gzip$)|(gzip, *deflate)').test(contentEncoding);\n            this.message.on('data', function (data) {\n                const chunk = (typeof data === 'string') ? Buffer.from(data, encodingCharset) : data;\n                chunks.push(chunk);\n            }).on('end', function () {\n                return __awaiter(this, void 0, void 0, function* () {\n                    const buffer = Buffer.concat(chunks);\n                    if (isGzippedEncoded) { // Process GZipped Response Body HERE\n                        const gunzippedBody = yield util.decompressGzippedContent(buffer, encodingCharset);\n                        resolve(gunzippedBody);\n                    }\n                    else {\n                        resolve(buffer.toString(encodingCharset));\n                    }\n                });\n            }).on('error', function (err) {\n                reject(err);\n            });\n        }));\n    }\n}\nexports.HttpClientResponse = HttpClientResponse;\nfunction isHttps(requestUrl) {\n    let parsedUrl = url.parse(requestUrl);\n    return parsedUrl.protocol === 'https:';\n}\nvar EnvironmentVariables;\n(function (EnvironmentVariables) {\n    EnvironmentVariables[\"HTTP_PROXY\"] = \"HTTP_PROXY\";\n    EnvironmentVariables[\"HTTPS_PROXY\"] = \"HTTPS_PROXY\";\n    EnvironmentVariables[\"NO_PROXY\"] = \"NO_PROXY\";\n})(EnvironmentVariables || (EnvironmentVariables = {}));\nclass HttpClient {\n    constructor(userAgent, handlers, requestOptions) {\n        this._ignoreSslError = false;\n        this._allowRedirects = true;\n        this._allowRedirectDowngrade = false;\n        this._maxRedirects = 50;\n        this._allowRetries = false;\n        this._maxRetries = 1;\n        this._keepAlive = false;\n        this._disposed = false;\n        this._httpGlobalAgentOptions = {\n            keepAlive: false,\n            timeout: 30000\n        };\n        this.userAgent = userAgent;\n        this.handlers = handlers || [];\n        let no_proxy = process.env[EnvironmentVariables.NO_PROXY];\n        if (no_proxy) {\n            this._httpProxyBypassHosts = [];\n            no_proxy.split(',').forEach(bypass => {\n                this._httpProxyBypassHosts.push(util.buildProxyBypassRegexFromEnv(bypass));\n            });\n        }\n        this.requestOptions = requestOptions;\n        if (requestOptions) {\n            if (requestOptions.ignoreSslError != null) {\n                this._ignoreSslError = requestOptions.ignoreSslError;\n            }\n            this._socketTimeout = requestOptions.socketTimeout;\n            this._httpProxy = requestOptions.proxy;\n            if (requestOptions.proxy && requestOptions.proxy.proxyBypassHosts) {\n                this._httpProxyBypassHosts = [];\n                requestOptions.proxy.proxyBypassHosts.forEach(bypass => {\n                    this._httpProxyBypassHosts.push(new RegExp(bypass, 'i'));\n                });\n            }\n            if (requestOptions.globalAgentOptions) {\n                this._httpGlobalAgentOptions = requestOptions.globalAgentOptions;\n            }\n            this._certConfig = requestOptions.cert;\n            if (this._certConfig) {\n                // If using cert, need fs\n                fs = __webpack_require__(/*! fs */ \"fs\");\n                // cache the cert content into memory, so we don't have to read it from disk every time\n                if (this._certConfig.caFile && fs.existsSync(this._certConfig.caFile)) {\n                    this._ca = fs.readFileSync(this._certConfig.caFile, 'utf8');\n                }\n                if (this._certConfig.certFile && fs.existsSync(this._certConfig.certFile)) {\n                    this._cert = fs.readFileSync(this._certConfig.certFile, 'utf8');\n                }\n                if (this._certConfig.keyFile && fs.existsSync(this._certConfig.keyFile)) {\n                    this._key = fs.readFileSync(this._certConfig.keyFile, 'utf8');\n                }\n            }\n            if (requestOptions.allowRedirects != null) {\n                this._allowRedirects = requestOptions.allowRedirects;\n            }\n            if (requestOptions.allowRedirectDowngrade != null) {\n                this._allowRedirectDowngrade = requestOptions.allowRedirectDowngrade;\n            }\n            if (requestOptions.maxRedirects != null) {\n                this._maxRedirects = Math.max(requestOptions.maxRedirects, 0);\n            }\n            if (requestOptions.keepAlive != null) {\n                this._keepAlive = requestOptions.keepAlive;\n            }\n            if (requestOptions.allowRetries != null) {\n                this._allowRetries = requestOptions.allowRetries;\n            }\n            if (requestOptions.maxRetries != null) {\n                this._maxRetries = requestOptions.maxRetries;\n            }\n        }\n    }\n    options(requestUrl, additionalHeaders) {\n        return this.request('OPTIONS', requestUrl, null, additionalHeaders || {});\n    }\n    get(requestUrl, additionalHeaders) {\n        return this.request('GET', requestUrl, null, additionalHeaders || {});\n    }\n    del(requestUrl, additionalHeaders) {\n        return this.request('DELETE', requestUrl, null, additionalHeaders || {});\n    }\n    post(requestUrl, data, additionalHeaders) {\n        return this.request('POST', requestUrl, data, additionalHeaders || {});\n    }\n    patch(requestUrl, data, additionalHeaders) {\n        return this.request('PATCH', requestUrl, data, additionalHeaders || {});\n    }\n    put(requestUrl, data, additionalHeaders) {\n        return this.request('PUT', requestUrl, data, additionalHeaders || {});\n    }\n    head(requestUrl, additionalHeaders) {\n        return this.request('HEAD', requestUrl, null, additionalHeaders || {});\n    }\n    sendStream(verb, requestUrl, stream, additionalHeaders) {\n        return this.request(verb, requestUrl, stream, additionalHeaders);\n    }\n    /**\n     * Makes a raw http request.\n     * All other methods such as get, post, patch, and request ultimately call this.\n     * Prefer get, del, post and patch\n     */\n    request(verb, requestUrl, data, headers) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (this._disposed) {\n                throw new Error(\"Client has already been disposed.\");\n            }\n            let parsedUrl = url.parse(requestUrl);\n            let info = this._prepareRequest(verb, parsedUrl, headers);\n            // Only perform retries on reads since writes may not be idempotent.\n            let maxTries = (this._allowRetries && RetryableHttpVerbs.indexOf(verb) != -1) ? this._maxRetries + 1 : 1;\n            let numTries = 0;\n            let response;\n            while (numTries < maxTries) {\n                try {\n                    response = yield this.requestRaw(info, data);\n                }\n                catch (err) {\n                    numTries++;\n                    if (err && err.code && NetworkRetryErrors.indexOf(err.code) > -1 && numTries < maxTries) {\n                        yield this._performExponentialBackoff(numTries);\n                        continue;\n                    }\n                    throw err;\n                }\n                // Check if it's an authentication challenge\n                if (response && response.message && response.message.statusCode === HttpCodes.Unauthorized) {\n                    let authenticationHandler;\n                    for (let i = 0; i < this.handlers.length; i++) {\n                        if (this.handlers[i].canHandleAuthentication(response)) {\n                            authenticationHandler = this.handlers[i];\n                            break;\n                        }\n                    }\n                    if (authenticationHandler) {\n                        return authenticationHandler.handleAuthentication(this, info, data);\n                    }\n                    else {\n                        // We have received an unauthorized response but have no handlers to handle it.\n                        // Let the response return to the caller.\n                        return response;\n                    }\n                }\n                let redirectsRemaining = this._maxRedirects;\n                while (HttpRedirectCodes.indexOf(response.message.statusCode) != -1\n                    && this._allowRedirects\n                    && redirectsRemaining > 0) {\n                    const redirectUrl = response.message.headers[\"location\"];\n                    if (!redirectUrl) {\n                        // if there's no location to redirect to, we won't\n                        break;\n                    }\n                    let parsedRedirectUrl = url.parse(redirectUrl);\n                    if (parsedUrl.protocol == 'https:' && parsedUrl.protocol != parsedRedirectUrl.protocol && !this._allowRedirectDowngrade) {\n                        throw new Error(\"Redirect from HTTPS to HTTP protocol. This downgrade is not allowed for security reasons. If you want to allow this behavior, set the allowRedirectDowngrade option to true.\");\n                    }\n                    // we need to finish reading the response before reassigning response\n                    // which will leak the open socket.\n                    yield response.readBody();\n                    // let's make the request with the new redirectUrl\n                    info = this._prepareRequest(verb, parsedRedirectUrl, headers);\n                    response = yield this.requestRaw(info, data);\n                    redirectsRemaining--;\n                }\n                if (HttpResponseRetryCodes.indexOf(response.message.statusCode) == -1) {\n                    // If not a retry code, return immediately instead of retrying\n                    return response;\n                }\n                numTries += 1;\n                if (numTries < maxTries) {\n                    yield response.readBody();\n                    yield this._performExponentialBackoff(numTries);\n                }\n            }\n            return response;\n        });\n    }\n    /**\n     * Needs to be called if keepAlive is set to true in request options.\n     */\n    dispose() {\n        if (this._agent) {\n            this._agent.destroy();\n        }\n        this._disposed = true;\n    }\n    /**\n     * Raw request.\n     * @param info\n     * @param data\n     */\n    requestRaw(info, data) {\n        return new Promise((resolve, reject) => {\n            let callbackForResult = function (err, res) {\n                if (err) {\n                    reject(err);\n                }\n                resolve(res);\n            };\n            this.requestRawWithCallback(info, data, callbackForResult);\n        });\n    }\n    /**\n     * Raw request with callback.\n     * @param info\n     * @param data\n     * @param onResult\n     */\n    requestRawWithCallback(info, data, onResult) {\n        let socket;\n        if (typeof (data) === 'string') {\n            info.options.headers[\"Content-Length\"] = Buffer.byteLength(data, 'utf8');\n        }\n        let callbackCalled = false;\n        let handleResult = (err, res) => {\n            if (!callbackCalled) {\n                callbackCalled = true;\n                onResult(err, res);\n            }\n        };\n        let req = info.httpModule.request(info.options, (msg) => {\n            let res = new HttpClientResponse(msg);\n            handleResult(null, res);\n        });\n        req.on('socket', (sock) => {\n            socket = sock;\n        });\n        // If we ever get disconnected, we want the socket to timeout eventually\n        req.setTimeout(this._socketTimeout || 3 * 60000, () => {\n            if (socket) {\n                socket.destroy();\n            }\n            handleResult(new Error('Request timeout: ' + info.options.path), null);\n        });\n        req.on('error', function (err) {\n            // err has statusCode property\n            // res should have headers\n            handleResult(err, null);\n        });\n        if (data && typeof (data) === 'string') {\n            req.write(data, 'utf8');\n        }\n        if (data && typeof (data) !== 'string') {\n            data.on('close', function () {\n                req.end();\n            });\n            data.pipe(req);\n        }\n        else {\n            req.end();\n        }\n    }\n    _prepareRequest(method, requestUrl, headers) {\n        const info = {};\n        info.parsedUrl = requestUrl;\n        const usingSsl = info.parsedUrl.protocol === 'https:';\n        info.httpModule = usingSsl ? https : http;\n        const defaultPort = usingSsl ? 443 : 80;\n        info.options = {};\n        info.options.host = info.parsedUrl.hostname;\n        info.options.port = info.parsedUrl.port ? parseInt(info.parsedUrl.port) : defaultPort;\n        info.options.path = (info.parsedUrl.pathname || '') + (info.parsedUrl.search || '');\n        info.options.method = method;\n        info.options.timeout = (this.requestOptions && this.requestOptions.socketTimeout) || this._socketTimeout;\n        this._socketTimeout = info.options.timeout;\n        info.options.headers = this._mergeHeaders(headers);\n        if (this.userAgent != null) {\n            info.options.headers[\"user-agent\"] = this.userAgent;\n        }\n        info.options.agent = this._getAgent(info.parsedUrl);\n        // gives handlers an opportunity to participate\n        if (this.handlers && !this._isPresigned(url.format(requestUrl))) {\n            this.handlers.forEach((handler) => {\n                handler.prepareRequest(info.options);\n            });\n        }\n        return info;\n    }\n    _isPresigned(requestUrl) {\n        if (this.requestOptions && this.requestOptions.presignedUrlPatterns) {\n            const patterns = this.requestOptions.presignedUrlPatterns;\n            for (let i = 0; i < patterns.length; i++) {\n                if (requestUrl.match(patterns[i])) {\n                    return true;\n                }\n            }\n        }\n        return false;\n    }\n    _mergeHeaders(headers) {\n        const lowercaseKeys = obj => Object.keys(obj).reduce((c, k) => (c[k.toLowerCase()] = obj[k], c), {});\n        if (this.requestOptions && this.requestOptions.headers) {\n            return Object.assign({}, lowercaseKeys(this.requestOptions.headers), lowercaseKeys(headers));\n        }\n        return lowercaseKeys(headers || {});\n    }\n    _getAgent(parsedUrl) {\n        let agent;\n        let proxy = this._getProxy(parsedUrl);\n        let useProxy = proxy.proxyUrl && proxy.proxyUrl.hostname && !this._isMatchInBypassProxyList(parsedUrl);\n        if (this._keepAlive && useProxy) {\n            agent = this._proxyAgent;\n        }\n        if (this._keepAlive && !useProxy) {\n            agent = this._agent;\n        }\n        // if agent is already assigned use that agent.\n        if (!!agent) {\n            return agent;\n        }\n        const usingSsl = parsedUrl.protocol === 'https:';\n        let maxSockets = 100;\n        if (!!this.requestOptions) {\n            maxSockets = this.requestOptions.maxSockets || http.globalAgent.maxSockets;\n        }\n        if (useProxy) {\n            // If using proxy, need tunnel\n            if (!tunnel) {\n                tunnel = __webpack_require__(/*! tunnel */ \"(rsc)/./node_modules/tunnel/index.js\");\n            }\n            const agentOptions = {\n                maxSockets: maxSockets,\n                keepAlive: this._keepAlive,\n                proxy: {\n                    proxyAuth: proxy.proxyAuth,\n                    host: proxy.proxyUrl.hostname,\n                    port: proxy.proxyUrl.port\n                },\n            };\n            let tunnelAgent;\n            const overHttps = proxy.proxyUrl.protocol === 'https:';\n            if (usingSsl) {\n                tunnelAgent = overHttps ? tunnel.httpsOverHttps : tunnel.httpsOverHttp;\n            }\n            else {\n                tunnelAgent = overHttps ? tunnel.httpOverHttps : tunnel.httpOverHttp;\n            }\n            agent = tunnelAgent(agentOptions);\n            this._proxyAgent = agent;\n        }\n        // if reusing agent across request and tunneling agent isn't assigned create a new agent\n        if (this._keepAlive && !agent) {\n            const options = { keepAlive: this._keepAlive, maxSockets: maxSockets };\n            agent = usingSsl ? new https.Agent(options) : new http.Agent(options);\n            this._agent = agent;\n        }\n        // if not using private agent and tunnel agent isn't setup then use global agent\n        if (!agent) {\n            const globalAgentOptions = {\n                keepAlive: this._httpGlobalAgentOptions.keepAlive,\n                timeout: this._httpGlobalAgentOptions.timeout\n            };\n            agent = usingSsl ? new https.Agent(globalAgentOptions) : new http.Agent(globalAgentOptions);\n        }\n        if (usingSsl && this._ignoreSslError) {\n            // we don't want to set NODE_TLS_REJECT_UNAUTHORIZED=0 since that will affect request for entire process\n            // http.RequestOptions doesn't expose a way to modify RequestOptions.agent.options\n            // we have to cast it to any and change it directly\n            agent.options = Object.assign(agent.options || {}, { rejectUnauthorized: false });\n        }\n        if (usingSsl && this._certConfig) {\n            agent.options = Object.assign(agent.options || {}, { ca: this._ca, cert: this._cert, key: this._key, passphrase: this._certConfig.passphrase });\n        }\n        return agent;\n    }\n    _getProxy(parsedUrl) {\n        let usingSsl = parsedUrl.protocol === 'https:';\n        let proxyConfig = this._httpProxy;\n        // fallback to http_proxy and https_proxy env\n        let https_proxy = process.env[EnvironmentVariables.HTTPS_PROXY];\n        let http_proxy = process.env[EnvironmentVariables.HTTP_PROXY];\n        if (!proxyConfig) {\n            if (https_proxy && usingSsl) {\n                proxyConfig = {\n                    proxyUrl: https_proxy\n                };\n            }\n            else if (http_proxy) {\n                proxyConfig = {\n                    proxyUrl: http_proxy\n                };\n            }\n        }\n        let proxyUrl;\n        let proxyAuth;\n        if (proxyConfig) {\n            if (proxyConfig.proxyUrl.length > 0) {\n                proxyUrl = url.parse(proxyConfig.proxyUrl);\n            }\n            if (proxyConfig.proxyUsername || proxyConfig.proxyPassword) {\n                proxyAuth = proxyConfig.proxyUsername + \":\" + proxyConfig.proxyPassword;\n            }\n        }\n        return { proxyUrl: proxyUrl, proxyAuth: proxyAuth };\n    }\n    _isMatchInBypassProxyList(parsedUrl) {\n        if (!this._httpProxyBypassHosts) {\n            return false;\n        }\n        let bypass = false;\n        this._httpProxyBypassHosts.forEach(bypassHost => {\n            if (bypassHost.test(parsedUrl.href)) {\n                bypass = true;\n            }\n        });\n        return bypass;\n    }\n    _performExponentialBackoff(retryNumber) {\n        retryNumber = Math.min(ExponentialBackoffCeiling, retryNumber);\n        const ms = ExponentialBackoffTimeSlice * Math.pow(2, retryNumber);\n        return new Promise(resolve => setTimeout(() => resolve(), ms));\n    }\n}\nexports.HttpClient = HttpClient;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvdHlwZWQtcmVzdC1jbGllbnQvSHR0cENsaWVudC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QiwrREFBK0QsaUJBQWlCO0FBQzVHO0FBQ0Esb0NBQW9DLE1BQU0sK0JBQStCLFlBQVk7QUFDckYsbUNBQW1DLE1BQU0sbUNBQW1DLFlBQVk7QUFDeEYsZ0NBQWdDO0FBQ2hDO0FBQ0EsS0FBSztBQUNMO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELGtCQUFrQixHQUFHLDBCQUEwQixHQUFHLGlCQUFpQjtBQUNuRSxlQUFlO0FBQ2YsWUFBWSxtQkFBTyxDQUFDLGdCQUFLO0FBQ3pCLGFBQWEsbUJBQU8sQ0FBQyxrQkFBTTtBQUMzQixjQUFjLG1CQUFPLENBQUMsb0JBQU87QUFDN0IsYUFBYSxtQkFBTyxDQUFDLDhEQUFRO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxnQkFBZ0IsaUJBQWlCLGlCQUFpQjtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLDRDQUE0QztBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIsYUFBYTtBQUNiO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsb0RBQW9EO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsbUJBQU8sQ0FBQyxjQUFJO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnRkFBZ0Y7QUFDaEY7QUFDQTtBQUNBLDRFQUE0RTtBQUM1RTtBQUNBO0FBQ0EsK0VBQStFO0FBQy9FO0FBQ0E7QUFDQSw2RUFBNkU7QUFDN0U7QUFDQTtBQUNBLDhFQUE4RTtBQUM5RTtBQUNBO0FBQ0EsNEVBQTRFO0FBQzVFO0FBQ0E7QUFDQSw2RUFBNkU7QUFDN0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQywwQkFBMEI7QUFDOUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIscUJBQXFCO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyR0FBMkc7QUFDM0c7QUFDQSxtQ0FBbUM7QUFDbkM7QUFDQSwwQ0FBMEM7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixtQkFBTyxDQUFDLG9EQUFRO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2REFBNkQsSUFBSSwyQkFBMkI7QUFDNUY7QUFDQTtBQUNBLDZEQUE2RCxJQUFJLHlGQUF5RjtBQUMxSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCIiwic291cmNlcyI6WyJDOlxcUHJvamVjdHNcXEJ1aWxkTGF1bmNoZXJUZXN0XFxub2RlX21vZHVsZXNcXHR5cGVkLXJlc3QtY2xpZW50XFxIdHRwQ2xpZW50LmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuLy8gQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UuIFNlZSBMSUNFTlNFIGZpbGUgaW4gdGhlIHByb2plY3Qgcm9vdCBmb3IgZnVsbCBsaWNlbnNlIGluZm9ybWF0aW9uLlxudmFyIF9fYXdhaXRlciA9ICh0aGlzICYmIHRoaXMuX19hd2FpdGVyKSB8fCBmdW5jdGlvbiAodGhpc0FyZywgX2FyZ3VtZW50cywgUCwgZ2VuZXJhdG9yKSB7XG4gICAgZnVuY3Rpb24gYWRvcHQodmFsdWUpIHsgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgUCA/IHZhbHVlIDogbmV3IFAoZnVuY3Rpb24gKHJlc29sdmUpIHsgcmVzb2x2ZSh2YWx1ZSk7IH0pOyB9XG4gICAgcmV0dXJuIG5ldyAoUCB8fCAoUCA9IFByb21pc2UpKShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgIGZ1bmN0aW9uIGZ1bGZpbGxlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvci5uZXh0KHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cbiAgICAgICAgZnVuY3Rpb24gcmVqZWN0ZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3JbXCJ0aHJvd1wiXSh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG4gICAgICAgIGZ1bmN0aW9uIHN0ZXAocmVzdWx0KSB7IHJlc3VsdC5kb25lID8gcmVzb2x2ZShyZXN1bHQudmFsdWUpIDogYWRvcHQocmVzdWx0LnZhbHVlKS50aGVuKGZ1bGZpbGxlZCwgcmVqZWN0ZWQpOyB9XG4gICAgICAgIHN0ZXAoKGdlbmVyYXRvciA9IGdlbmVyYXRvci5hcHBseSh0aGlzQXJnLCBfYXJndW1lbnRzIHx8IFtdKSkubmV4dCgpKTtcbiAgICB9KTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkh0dHBDbGllbnQgPSBleHBvcnRzLkh0dHBDbGllbnRSZXNwb25zZSA9IGV4cG9ydHMuSHR0cENvZGVzID0gdm9pZCAwO1xuZXhwb3J0cy5pc0h0dHBzID0gaXNIdHRwcztcbmNvbnN0IHVybCA9IHJlcXVpcmUoXCJ1cmxcIik7XG5jb25zdCBodHRwID0gcmVxdWlyZShcImh0dHBcIik7XG5jb25zdCBodHRwcyA9IHJlcXVpcmUoXCJodHRwc1wiKTtcbmNvbnN0IHV0aWwgPSByZXF1aXJlKFwiLi9VdGlsXCIpO1xubGV0IGZzO1xubGV0IHR1bm5lbDtcbnZhciBIdHRwQ29kZXM7XG4oZnVuY3Rpb24gKEh0dHBDb2Rlcykge1xuICAgIEh0dHBDb2Rlc1tIdHRwQ29kZXNbXCJPS1wiXSA9IDIwMF0gPSBcIk9LXCI7XG4gICAgSHR0cENvZGVzW0h0dHBDb2Rlc1tcIk11bHRpcGxlQ2hvaWNlc1wiXSA9IDMwMF0gPSBcIk11bHRpcGxlQ2hvaWNlc1wiO1xuICAgIEh0dHBDb2Rlc1tIdHRwQ29kZXNbXCJNb3ZlZFBlcm1hbmVudGx5XCJdID0gMzAxXSA9IFwiTW92ZWRQZXJtYW5lbnRseVwiO1xuICAgIEh0dHBDb2Rlc1tIdHRwQ29kZXNbXCJSZXNvdXJjZU1vdmVkXCJdID0gMzAyXSA9IFwiUmVzb3VyY2VNb3ZlZFwiO1xuICAgIEh0dHBDb2Rlc1tIdHRwQ29kZXNbXCJTZWVPdGhlclwiXSA9IDMwM10gPSBcIlNlZU90aGVyXCI7XG4gICAgSHR0cENvZGVzW0h0dHBDb2Rlc1tcIk5vdE1vZGlmaWVkXCJdID0gMzA0XSA9IFwiTm90TW9kaWZpZWRcIjtcbiAgICBIdHRwQ29kZXNbSHR0cENvZGVzW1wiVXNlUHJveHlcIl0gPSAzMDVdID0gXCJVc2VQcm94eVwiO1xuICAgIEh0dHBDb2Rlc1tIdHRwQ29kZXNbXCJTd2l0Y2hQcm94eVwiXSA9IDMwNl0gPSBcIlN3aXRjaFByb3h5XCI7XG4gICAgSHR0cENvZGVzW0h0dHBDb2Rlc1tcIlRlbXBvcmFyeVJlZGlyZWN0XCJdID0gMzA3XSA9IFwiVGVtcG9yYXJ5UmVkaXJlY3RcIjtcbiAgICBIdHRwQ29kZXNbSHR0cENvZGVzW1wiUGVybWFuZW50UmVkaXJlY3RcIl0gPSAzMDhdID0gXCJQZXJtYW5lbnRSZWRpcmVjdFwiO1xuICAgIEh0dHBDb2Rlc1tIdHRwQ29kZXNbXCJCYWRSZXF1ZXN0XCJdID0gNDAwXSA9IFwiQmFkUmVxdWVzdFwiO1xuICAgIEh0dHBDb2Rlc1tIdHRwQ29kZXNbXCJVbmF1dGhvcml6ZWRcIl0gPSA0MDFdID0gXCJVbmF1dGhvcml6ZWRcIjtcbiAgICBIdHRwQ29kZXNbSHR0cENvZGVzW1wiUGF5bWVudFJlcXVpcmVkXCJdID0gNDAyXSA9IFwiUGF5bWVudFJlcXVpcmVkXCI7XG4gICAgSHR0cENvZGVzW0h0dHBDb2Rlc1tcIkZvcmJpZGRlblwiXSA9IDQwM10gPSBcIkZvcmJpZGRlblwiO1xuICAgIEh0dHBDb2Rlc1tIdHRwQ29kZXNbXCJOb3RGb3VuZFwiXSA9IDQwNF0gPSBcIk5vdEZvdW5kXCI7XG4gICAgSHR0cENvZGVzW0h0dHBDb2Rlc1tcIk1ldGhvZE5vdEFsbG93ZWRcIl0gPSA0MDVdID0gXCJNZXRob2ROb3RBbGxvd2VkXCI7XG4gICAgSHR0cENvZGVzW0h0dHBDb2Rlc1tcIk5vdEFjY2VwdGFibGVcIl0gPSA0MDZdID0gXCJOb3RBY2NlcHRhYmxlXCI7XG4gICAgSHR0cENvZGVzW0h0dHBDb2Rlc1tcIlByb3h5QXV0aGVudGljYXRpb25SZXF1aXJlZFwiXSA9IDQwN10gPSBcIlByb3h5QXV0aGVudGljYXRpb25SZXF1aXJlZFwiO1xuICAgIEh0dHBDb2Rlc1tIdHRwQ29kZXNbXCJSZXF1ZXN0VGltZW91dFwiXSA9IDQwOF0gPSBcIlJlcXVlc3RUaW1lb3V0XCI7XG4gICAgSHR0cENvZGVzW0h0dHBDb2Rlc1tcIkNvbmZsaWN0XCJdID0gNDA5XSA9IFwiQ29uZmxpY3RcIjtcbiAgICBIdHRwQ29kZXNbSHR0cENvZGVzW1wiR29uZVwiXSA9IDQxMF0gPSBcIkdvbmVcIjtcbiAgICBIdHRwQ29kZXNbSHR0cENvZGVzW1wiVG9vTWFueVJlcXVlc3RzXCJdID0gNDI5XSA9IFwiVG9vTWFueVJlcXVlc3RzXCI7XG4gICAgSHR0cENvZGVzW0h0dHBDb2Rlc1tcIkludGVybmFsU2VydmVyRXJyb3JcIl0gPSA1MDBdID0gXCJJbnRlcm5hbFNlcnZlckVycm9yXCI7XG4gICAgSHR0cENvZGVzW0h0dHBDb2Rlc1tcIk5vdEltcGxlbWVudGVkXCJdID0gNTAxXSA9IFwiTm90SW1wbGVtZW50ZWRcIjtcbiAgICBIdHRwQ29kZXNbSHR0cENvZGVzW1wiQmFkR2F0ZXdheVwiXSA9IDUwMl0gPSBcIkJhZEdhdGV3YXlcIjtcbiAgICBIdHRwQ29kZXNbSHR0cENvZGVzW1wiU2VydmljZVVuYXZhaWxhYmxlXCJdID0gNTAzXSA9IFwiU2VydmljZVVuYXZhaWxhYmxlXCI7XG4gICAgSHR0cENvZGVzW0h0dHBDb2Rlc1tcIkdhdGV3YXlUaW1lb3V0XCJdID0gNTA0XSA9IFwiR2F0ZXdheVRpbWVvdXRcIjtcbn0pKEh0dHBDb2RlcyB8fCAoZXhwb3J0cy5IdHRwQ29kZXMgPSBIdHRwQ29kZXMgPSB7fSkpO1xuY29uc3QgSHR0cFJlZGlyZWN0Q29kZXMgPSBbSHR0cENvZGVzLk1vdmVkUGVybWFuZW50bHksIEh0dHBDb2Rlcy5SZXNvdXJjZU1vdmVkLCBIdHRwQ29kZXMuU2VlT3RoZXIsIEh0dHBDb2Rlcy5UZW1wb3JhcnlSZWRpcmVjdCwgSHR0cENvZGVzLlBlcm1hbmVudFJlZGlyZWN0XTtcbmNvbnN0IEh0dHBSZXNwb25zZVJldHJ5Q29kZXMgPSBbSHR0cENvZGVzLkJhZEdhdGV3YXksIEh0dHBDb2Rlcy5TZXJ2aWNlVW5hdmFpbGFibGUsIEh0dHBDb2Rlcy5HYXRld2F5VGltZW91dF07XG5jb25zdCBOZXR3b3JrUmV0cnlFcnJvcnMgPSBbJ0VDT05OUkVTRVQnLCAnRU5PVEZPVU5EJywgJ0VTT0NLRVRUSU1FRE9VVCcsICdFVElNRURPVVQnLCAnRUNPTk5SRUZVU0VEJywgJ0VIT1NUVU5SRUFDSCddO1xuY29uc3QgUmV0cnlhYmxlSHR0cFZlcmJzID0gWydPUFRJT05TJywgJ0dFVCcsICdERUxFVEUnLCAnSEVBRCddO1xuY29uc3QgRXhwb25lbnRpYWxCYWNrb2ZmQ2VpbGluZyA9IDEwO1xuY29uc3QgRXhwb25lbnRpYWxCYWNrb2ZmVGltZVNsaWNlID0gNTtcbmNsYXNzIEh0dHBDbGllbnRSZXNwb25zZSB7XG4gICAgY29uc3RydWN0b3IobWVzc2FnZSkge1xuICAgICAgICB0aGlzLm1lc3NhZ2UgPSBtZXNzYWdlO1xuICAgIH1cbiAgICByZWFkQm9keSgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGNvbnN0IGNodW5rcyA9IFtdO1xuICAgICAgICAgICAgY29uc3QgZW5jb2RpbmdDaGFyc2V0ID0gdXRpbC5vYnRhaW5Db250ZW50Q2hhcnNldCh0aGlzKTtcbiAgICAgICAgICAgIC8vIEV4dHJhY3QgRW5jb2RpbmcgZnJvbSBoZWFkZXI6ICdjb250ZW50LWVuY29kaW5nJ1xuICAgICAgICAgICAgLy8gTWF0Y2ggYGd6aXBgLCBgZ3ppcCwgZGVmbGF0ZWAgdmFyaWF0aW9ucyBvZiBHWklQIGVuY29kaW5nXG4gICAgICAgICAgICBjb25zdCBjb250ZW50RW5jb2RpbmcgPSB0aGlzLm1lc3NhZ2UuaGVhZGVyc1snY29udGVudC1lbmNvZGluZyddIHx8ICcnO1xuICAgICAgICAgICAgY29uc3QgaXNHemlwcGVkRW5jb2RlZCA9IG5ldyBSZWdFeHAoJyhnemlwJCl8KGd6aXAsICpkZWZsYXRlKScpLnRlc3QoY29udGVudEVuY29kaW5nKTtcbiAgICAgICAgICAgIHRoaXMubWVzc2FnZS5vbignZGF0YScsIGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgY2h1bmsgPSAodHlwZW9mIGRhdGEgPT09ICdzdHJpbmcnKSA/IEJ1ZmZlci5mcm9tKGRhdGEsIGVuY29kaW5nQ2hhcnNldCkgOiBkYXRhO1xuICAgICAgICAgICAgICAgIGNodW5rcy5wdXNoKGNodW5rKTtcbiAgICAgICAgICAgIH0pLm9uKCdlbmQnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgYnVmZmVyID0gQnVmZmVyLmNvbmNhdChjaHVua3MpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoaXNHemlwcGVkRW5jb2RlZCkgeyAvLyBQcm9jZXNzIEdaaXBwZWQgUmVzcG9uc2UgQm9keSBIRVJFXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBndW56aXBwZWRCb2R5ID0geWllbGQgdXRpbC5kZWNvbXByZXNzR3ppcHBlZENvbnRlbnQoYnVmZmVyLCBlbmNvZGluZ0NoYXJzZXQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZShndW56aXBwZWRCb2R5KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmUoYnVmZmVyLnRvU3RyaW5nKGVuY29kaW5nQ2hhcnNldCkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KS5vbignZXJyb3InLCBmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgcmVqZWN0KGVycik7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSkpO1xuICAgIH1cbn1cbmV4cG9ydHMuSHR0cENsaWVudFJlc3BvbnNlID0gSHR0cENsaWVudFJlc3BvbnNlO1xuZnVuY3Rpb24gaXNIdHRwcyhyZXF1ZXN0VXJsKSB7XG4gICAgbGV0IHBhcnNlZFVybCA9IHVybC5wYXJzZShyZXF1ZXN0VXJsKTtcbiAgICByZXR1cm4gcGFyc2VkVXJsLnByb3RvY29sID09PSAnaHR0cHM6Jztcbn1cbnZhciBFbnZpcm9ubWVudFZhcmlhYmxlcztcbihmdW5jdGlvbiAoRW52aXJvbm1lbnRWYXJpYWJsZXMpIHtcbiAgICBFbnZpcm9ubWVudFZhcmlhYmxlc1tcIkhUVFBfUFJPWFlcIl0gPSBcIkhUVFBfUFJPWFlcIjtcbiAgICBFbnZpcm9ubWVudFZhcmlhYmxlc1tcIkhUVFBTX1BST1hZXCJdID0gXCJIVFRQU19QUk9YWVwiO1xuICAgIEVudmlyb25tZW50VmFyaWFibGVzW1wiTk9fUFJPWFlcIl0gPSBcIk5PX1BST1hZXCI7XG59KShFbnZpcm9ubWVudFZhcmlhYmxlcyB8fCAoRW52aXJvbm1lbnRWYXJpYWJsZXMgPSB7fSkpO1xuY2xhc3MgSHR0cENsaWVudCB7XG4gICAgY29uc3RydWN0b3IodXNlckFnZW50LCBoYW5kbGVycywgcmVxdWVzdE9wdGlvbnMpIHtcbiAgICAgICAgdGhpcy5faWdub3JlU3NsRXJyb3IgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5fYWxsb3dSZWRpcmVjdHMgPSB0cnVlO1xuICAgICAgICB0aGlzLl9hbGxvd1JlZGlyZWN0RG93bmdyYWRlID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX21heFJlZGlyZWN0cyA9IDUwO1xuICAgICAgICB0aGlzLl9hbGxvd1JldHJpZXMgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5fbWF4UmV0cmllcyA9IDE7XG4gICAgICAgIHRoaXMuX2tlZXBBbGl2ZSA9IGZhbHNlO1xuICAgICAgICB0aGlzLl9kaXNwb3NlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLl9odHRwR2xvYmFsQWdlbnRPcHRpb25zID0ge1xuICAgICAgICAgICAga2VlcEFsaXZlOiBmYWxzZSxcbiAgICAgICAgICAgIHRpbWVvdXQ6IDMwMDAwXG4gICAgICAgIH07XG4gICAgICAgIHRoaXMudXNlckFnZW50ID0gdXNlckFnZW50O1xuICAgICAgICB0aGlzLmhhbmRsZXJzID0gaGFuZGxlcnMgfHwgW107XG4gICAgICAgIGxldCBub19wcm94eSA9IHByb2Nlc3MuZW52W0Vudmlyb25tZW50VmFyaWFibGVzLk5PX1BST1hZXTtcbiAgICAgICAgaWYgKG5vX3Byb3h5KSB7XG4gICAgICAgICAgICB0aGlzLl9odHRwUHJveHlCeXBhc3NIb3N0cyA9IFtdO1xuICAgICAgICAgICAgbm9fcHJveHkuc3BsaXQoJywnKS5mb3JFYWNoKGJ5cGFzcyA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5faHR0cFByb3h5QnlwYXNzSG9zdHMucHVzaCh1dGlsLmJ1aWxkUHJveHlCeXBhc3NSZWdleEZyb21FbnYoYnlwYXNzKSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnJlcXVlc3RPcHRpb25zID0gcmVxdWVzdE9wdGlvbnM7XG4gICAgICAgIGlmIChyZXF1ZXN0T3B0aW9ucykge1xuICAgICAgICAgICAgaWYgKHJlcXVlc3RPcHRpb25zLmlnbm9yZVNzbEVycm9yICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9pZ25vcmVTc2xFcnJvciA9IHJlcXVlc3RPcHRpb25zLmlnbm9yZVNzbEVycm9yO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5fc29ja2V0VGltZW91dCA9IHJlcXVlc3RPcHRpb25zLnNvY2tldFRpbWVvdXQ7XG4gICAgICAgICAgICB0aGlzLl9odHRwUHJveHkgPSByZXF1ZXN0T3B0aW9ucy5wcm94eTtcbiAgICAgICAgICAgIGlmIChyZXF1ZXN0T3B0aW9ucy5wcm94eSAmJiByZXF1ZXN0T3B0aW9ucy5wcm94eS5wcm94eUJ5cGFzc0hvc3RzKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5faHR0cFByb3h5QnlwYXNzSG9zdHMgPSBbXTtcbiAgICAgICAgICAgICAgICByZXF1ZXN0T3B0aW9ucy5wcm94eS5wcm94eUJ5cGFzc0hvc3RzLmZvckVhY2goYnlwYXNzID0+IHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5faHR0cFByb3h5QnlwYXNzSG9zdHMucHVzaChuZXcgUmVnRXhwKGJ5cGFzcywgJ2knKSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocmVxdWVzdE9wdGlvbnMuZ2xvYmFsQWdlbnRPcHRpb25zKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5faHR0cEdsb2JhbEFnZW50T3B0aW9ucyA9IHJlcXVlc3RPcHRpb25zLmdsb2JhbEFnZW50T3B0aW9ucztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuX2NlcnRDb25maWcgPSByZXF1ZXN0T3B0aW9ucy5jZXJ0O1xuICAgICAgICAgICAgaWYgKHRoaXMuX2NlcnRDb25maWcpIHtcbiAgICAgICAgICAgICAgICAvLyBJZiB1c2luZyBjZXJ0LCBuZWVkIGZzXG4gICAgICAgICAgICAgICAgZnMgPSByZXF1aXJlKCdmcycpO1xuICAgICAgICAgICAgICAgIC8vIGNhY2hlIHRoZSBjZXJ0IGNvbnRlbnQgaW50byBtZW1vcnksIHNvIHdlIGRvbid0IGhhdmUgdG8gcmVhZCBpdCBmcm9tIGRpc2sgZXZlcnkgdGltZVxuICAgICAgICAgICAgICAgIGlmICh0aGlzLl9jZXJ0Q29uZmlnLmNhRmlsZSAmJiBmcy5leGlzdHNTeW5jKHRoaXMuX2NlcnRDb25maWcuY2FGaWxlKSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9jYSA9IGZzLnJlYWRGaWxlU3luYyh0aGlzLl9jZXJ0Q29uZmlnLmNhRmlsZSwgJ3V0ZjgnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX2NlcnRDb25maWcuY2VydEZpbGUgJiYgZnMuZXhpc3RzU3luYyh0aGlzLl9jZXJ0Q29uZmlnLmNlcnRGaWxlKSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9jZXJ0ID0gZnMucmVhZEZpbGVTeW5jKHRoaXMuX2NlcnRDb25maWcuY2VydEZpbGUsICd1dGY4Jyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICh0aGlzLl9jZXJ0Q29uZmlnLmtleUZpbGUgJiYgZnMuZXhpc3RzU3luYyh0aGlzLl9jZXJ0Q29uZmlnLmtleUZpbGUpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2tleSA9IGZzLnJlYWRGaWxlU3luYyh0aGlzLl9jZXJ0Q29uZmlnLmtleUZpbGUsICd1dGY4Jyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHJlcXVlc3RPcHRpb25zLmFsbG93UmVkaXJlY3RzICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9hbGxvd1JlZGlyZWN0cyA9IHJlcXVlc3RPcHRpb25zLmFsbG93UmVkaXJlY3RzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHJlcXVlc3RPcHRpb25zLmFsbG93UmVkaXJlY3REb3duZ3JhZGUgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2FsbG93UmVkaXJlY3REb3duZ3JhZGUgPSByZXF1ZXN0T3B0aW9ucy5hbGxvd1JlZGlyZWN0RG93bmdyYWRlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHJlcXVlc3RPcHRpb25zLm1heFJlZGlyZWN0cyAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fbWF4UmVkaXJlY3RzID0gTWF0aC5tYXgocmVxdWVzdE9wdGlvbnMubWF4UmVkaXJlY3RzLCAwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChyZXF1ZXN0T3B0aW9ucy5rZWVwQWxpdmUgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2tlZXBBbGl2ZSA9IHJlcXVlc3RPcHRpb25zLmtlZXBBbGl2ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChyZXF1ZXN0T3B0aW9ucy5hbGxvd1JldHJpZXMgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2FsbG93UmV0cmllcyA9IHJlcXVlc3RPcHRpb25zLmFsbG93UmV0cmllcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChyZXF1ZXN0T3B0aW9ucy5tYXhSZXRyaWVzICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9tYXhSZXRyaWVzID0gcmVxdWVzdE9wdGlvbnMubWF4UmV0cmllcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBvcHRpb25zKHJlcXVlc3RVcmwsIGFkZGl0aW9uYWxIZWFkZXJzKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJlcXVlc3QoJ09QVElPTlMnLCByZXF1ZXN0VXJsLCBudWxsLCBhZGRpdGlvbmFsSGVhZGVycyB8fCB7fSk7XG4gICAgfVxuICAgIGdldChyZXF1ZXN0VXJsLCBhZGRpdGlvbmFsSGVhZGVycykge1xuICAgICAgICByZXR1cm4gdGhpcy5yZXF1ZXN0KCdHRVQnLCByZXF1ZXN0VXJsLCBudWxsLCBhZGRpdGlvbmFsSGVhZGVycyB8fCB7fSk7XG4gICAgfVxuICAgIGRlbChyZXF1ZXN0VXJsLCBhZGRpdGlvbmFsSGVhZGVycykge1xuICAgICAgICByZXR1cm4gdGhpcy5yZXF1ZXN0KCdERUxFVEUnLCByZXF1ZXN0VXJsLCBudWxsLCBhZGRpdGlvbmFsSGVhZGVycyB8fCB7fSk7XG4gICAgfVxuICAgIHBvc3QocmVxdWVzdFVybCwgZGF0YSwgYWRkaXRpb25hbEhlYWRlcnMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucmVxdWVzdCgnUE9TVCcsIHJlcXVlc3RVcmwsIGRhdGEsIGFkZGl0aW9uYWxIZWFkZXJzIHx8IHt9KTtcbiAgICB9XG4gICAgcGF0Y2gocmVxdWVzdFVybCwgZGF0YSwgYWRkaXRpb25hbEhlYWRlcnMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucmVxdWVzdCgnUEFUQ0gnLCByZXF1ZXN0VXJsLCBkYXRhLCBhZGRpdGlvbmFsSGVhZGVycyB8fCB7fSk7XG4gICAgfVxuICAgIHB1dChyZXF1ZXN0VXJsLCBkYXRhLCBhZGRpdGlvbmFsSGVhZGVycykge1xuICAgICAgICByZXR1cm4gdGhpcy5yZXF1ZXN0KCdQVVQnLCByZXF1ZXN0VXJsLCBkYXRhLCBhZGRpdGlvbmFsSGVhZGVycyB8fCB7fSk7XG4gICAgfVxuICAgIGhlYWQocmVxdWVzdFVybCwgYWRkaXRpb25hbEhlYWRlcnMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucmVxdWVzdCgnSEVBRCcsIHJlcXVlc3RVcmwsIG51bGwsIGFkZGl0aW9uYWxIZWFkZXJzIHx8IHt9KTtcbiAgICB9XG4gICAgc2VuZFN0cmVhbSh2ZXJiLCByZXF1ZXN0VXJsLCBzdHJlYW0sIGFkZGl0aW9uYWxIZWFkZXJzKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJlcXVlc3QodmVyYiwgcmVxdWVzdFVybCwgc3RyZWFtLCBhZGRpdGlvbmFsSGVhZGVycyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIE1ha2VzIGEgcmF3IGh0dHAgcmVxdWVzdC5cbiAgICAgKiBBbGwgb3RoZXIgbWV0aG9kcyBzdWNoIGFzIGdldCwgcG9zdCwgcGF0Y2gsIGFuZCByZXF1ZXN0IHVsdGltYXRlbHkgY2FsbCB0aGlzLlxuICAgICAqIFByZWZlciBnZXQsIGRlbCwgcG9zdCBhbmQgcGF0Y2hcbiAgICAgKi9cbiAgICByZXF1ZXN0KHZlcmIsIHJlcXVlc3RVcmwsIGRhdGEsIGhlYWRlcnMpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLl9kaXNwb3NlZCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNsaWVudCBoYXMgYWxyZWFkeSBiZWVuIGRpc3Bvc2VkLlwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCBwYXJzZWRVcmwgPSB1cmwucGFyc2UocmVxdWVzdFVybCk7XG4gICAgICAgICAgICBsZXQgaW5mbyA9IHRoaXMuX3ByZXBhcmVSZXF1ZXN0KHZlcmIsIHBhcnNlZFVybCwgaGVhZGVycyk7XG4gICAgICAgICAgICAvLyBPbmx5IHBlcmZvcm0gcmV0cmllcyBvbiByZWFkcyBzaW5jZSB3cml0ZXMgbWF5IG5vdCBiZSBpZGVtcG90ZW50LlxuICAgICAgICAgICAgbGV0IG1heFRyaWVzID0gKHRoaXMuX2FsbG93UmV0cmllcyAmJiBSZXRyeWFibGVIdHRwVmVyYnMuaW5kZXhPZih2ZXJiKSAhPSAtMSkgPyB0aGlzLl9tYXhSZXRyaWVzICsgMSA6IDE7XG4gICAgICAgICAgICBsZXQgbnVtVHJpZXMgPSAwO1xuICAgICAgICAgICAgbGV0IHJlc3BvbnNlO1xuICAgICAgICAgICAgd2hpbGUgKG51bVRyaWVzIDwgbWF4VHJpZXMpIHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICByZXNwb25zZSA9IHlpZWxkIHRoaXMucmVxdWVzdFJhdyhpbmZvLCBkYXRhKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgICAgICBudW1UcmllcysrO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZXJyICYmIGVyci5jb2RlICYmIE5ldHdvcmtSZXRyeUVycm9ycy5pbmRleE9mKGVyci5jb2RlKSA+IC0xICYmIG51bVRyaWVzIDwgbWF4VHJpZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHlpZWxkIHRoaXMuX3BlcmZvcm1FeHBvbmVudGlhbEJhY2tvZmYobnVtVHJpZXMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBDaGVjayBpZiBpdCdzIGFuIGF1dGhlbnRpY2F0aW9uIGNoYWxsZW5nZVxuICAgICAgICAgICAgICAgIGlmIChyZXNwb25zZSAmJiByZXNwb25zZS5tZXNzYWdlICYmIHJlc3BvbnNlLm1lc3NhZ2Uuc3RhdHVzQ29kZSA9PT0gSHR0cENvZGVzLlVuYXV0aG9yaXplZCkge1xuICAgICAgICAgICAgICAgICAgICBsZXQgYXV0aGVudGljYXRpb25IYW5kbGVyO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuaGFuZGxlcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmhhbmRsZXJzW2ldLmNhbkhhbmRsZUF1dGhlbnRpY2F0aW9uKHJlc3BvbnNlKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGF1dGhlbnRpY2F0aW9uSGFuZGxlciA9IHRoaXMuaGFuZGxlcnNbaV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKGF1dGhlbnRpY2F0aW9uSGFuZGxlcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGF1dGhlbnRpY2F0aW9uSGFuZGxlci5oYW5kbGVBdXRoZW50aWNhdGlvbih0aGlzLCBpbmZvLCBkYXRhKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFdlIGhhdmUgcmVjZWl2ZWQgYW4gdW5hdXRob3JpemVkIHJlc3BvbnNlIGJ1dCBoYXZlIG5vIGhhbmRsZXJzIHRvIGhhbmRsZSBpdC5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIExldCB0aGUgcmVzcG9uc2UgcmV0dXJuIHRvIHRoZSBjYWxsZXIuXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzcG9uc2U7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbGV0IHJlZGlyZWN0c1JlbWFpbmluZyA9IHRoaXMuX21heFJlZGlyZWN0cztcbiAgICAgICAgICAgICAgICB3aGlsZSAoSHR0cFJlZGlyZWN0Q29kZXMuaW5kZXhPZihyZXNwb25zZS5tZXNzYWdlLnN0YXR1c0NvZGUpICE9IC0xXG4gICAgICAgICAgICAgICAgICAgICYmIHRoaXMuX2FsbG93UmVkaXJlY3RzXG4gICAgICAgICAgICAgICAgICAgICYmIHJlZGlyZWN0c1JlbWFpbmluZyA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVkaXJlY3RVcmwgPSByZXNwb25zZS5tZXNzYWdlLmhlYWRlcnNbXCJsb2NhdGlvblwiXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFyZWRpcmVjdFVybCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gaWYgdGhlcmUncyBubyBsb2NhdGlvbiB0byByZWRpcmVjdCB0bywgd2Ugd29uJ3RcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGxldCBwYXJzZWRSZWRpcmVjdFVybCA9IHVybC5wYXJzZShyZWRpcmVjdFVybCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChwYXJzZWRVcmwucHJvdG9jb2wgPT0gJ2h0dHBzOicgJiYgcGFyc2VkVXJsLnByb3RvY29sICE9IHBhcnNlZFJlZGlyZWN0VXJsLnByb3RvY29sICYmICF0aGlzLl9hbGxvd1JlZGlyZWN0RG93bmdyYWRlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJSZWRpcmVjdCBmcm9tIEhUVFBTIHRvIEhUVFAgcHJvdG9jb2wuIFRoaXMgZG93bmdyYWRlIGlzIG5vdCBhbGxvd2VkIGZvciBzZWN1cml0eSByZWFzb25zLiBJZiB5b3Ugd2FudCB0byBhbGxvdyB0aGlzIGJlaGF2aW9yLCBzZXQgdGhlIGFsbG93UmVkaXJlY3REb3duZ3JhZGUgb3B0aW9uIHRvIHRydWUuXCIpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIC8vIHdlIG5lZWQgdG8gZmluaXNoIHJlYWRpbmcgdGhlIHJlc3BvbnNlIGJlZm9yZSByZWFzc2lnbmluZyByZXNwb25zZVxuICAgICAgICAgICAgICAgICAgICAvLyB3aGljaCB3aWxsIGxlYWsgdGhlIG9wZW4gc29ja2V0LlxuICAgICAgICAgICAgICAgICAgICB5aWVsZCByZXNwb25zZS5yZWFkQm9keSgpO1xuICAgICAgICAgICAgICAgICAgICAvLyBsZXQncyBtYWtlIHRoZSByZXF1ZXN0IHdpdGggdGhlIG5ldyByZWRpcmVjdFVybFxuICAgICAgICAgICAgICAgICAgICBpbmZvID0gdGhpcy5fcHJlcGFyZVJlcXVlc3QodmVyYiwgcGFyc2VkUmVkaXJlY3RVcmwsIGhlYWRlcnMpO1xuICAgICAgICAgICAgICAgICAgICByZXNwb25zZSA9IHlpZWxkIHRoaXMucmVxdWVzdFJhdyhpbmZvLCBkYXRhKTtcbiAgICAgICAgICAgICAgICAgICAgcmVkaXJlY3RzUmVtYWluaW5nLS07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChIdHRwUmVzcG9uc2VSZXRyeUNvZGVzLmluZGV4T2YocmVzcG9uc2UubWVzc2FnZS5zdGF0dXNDb2RlKSA9PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBJZiBub3QgYSByZXRyeSBjb2RlLCByZXR1cm4gaW1tZWRpYXRlbHkgaW5zdGVhZCBvZiByZXRyeWluZ1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzcG9uc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIG51bVRyaWVzICs9IDE7XG4gICAgICAgICAgICAgICAgaWYgKG51bVRyaWVzIDwgbWF4VHJpZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgeWllbGQgcmVzcG9uc2UucmVhZEJvZHkoKTtcbiAgICAgICAgICAgICAgICAgICAgeWllbGQgdGhpcy5fcGVyZm9ybUV4cG9uZW50aWFsQmFja29mZihudW1Ucmllcyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogTmVlZHMgdG8gYmUgY2FsbGVkIGlmIGtlZXBBbGl2ZSBpcyBzZXQgdG8gdHJ1ZSBpbiByZXF1ZXN0IG9wdGlvbnMuXG4gICAgICovXG4gICAgZGlzcG9zZSgpIHtcbiAgICAgICAgaWYgKHRoaXMuX2FnZW50KSB7XG4gICAgICAgICAgICB0aGlzLl9hZ2VudC5kZXN0cm95KCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fZGlzcG9zZWQgPSB0cnVlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSYXcgcmVxdWVzdC5cbiAgICAgKiBAcGFyYW0gaW5mb1xuICAgICAqIEBwYXJhbSBkYXRhXG4gICAgICovXG4gICAgcmVxdWVzdFJhdyhpbmZvLCBkYXRhKSB7XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICBsZXQgY2FsbGJhY2tGb3JSZXN1bHQgPSBmdW5jdGlvbiAoZXJyLCByZXMpIHtcbiAgICAgICAgICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlamVjdChlcnIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXNvbHZlKHJlcyk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgdGhpcy5yZXF1ZXN0UmF3V2l0aENhbGxiYWNrKGluZm8sIGRhdGEsIGNhbGxiYWNrRm9yUmVzdWx0KTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJhdyByZXF1ZXN0IHdpdGggY2FsbGJhY2suXG4gICAgICogQHBhcmFtIGluZm9cbiAgICAgKiBAcGFyYW0gZGF0YVxuICAgICAqIEBwYXJhbSBvblJlc3VsdFxuICAgICAqL1xuICAgIHJlcXVlc3RSYXdXaXRoQ2FsbGJhY2soaW5mbywgZGF0YSwgb25SZXN1bHQpIHtcbiAgICAgICAgbGV0IHNvY2tldDtcbiAgICAgICAgaWYgKHR5cGVvZiAoZGF0YSkgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICBpbmZvLm9wdGlvbnMuaGVhZGVyc1tcIkNvbnRlbnQtTGVuZ3RoXCJdID0gQnVmZmVyLmJ5dGVMZW5ndGgoZGF0YSwgJ3V0ZjgnKTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgY2FsbGJhY2tDYWxsZWQgPSBmYWxzZTtcbiAgICAgICAgbGV0IGhhbmRsZVJlc3VsdCA9IChlcnIsIHJlcykgPT4ge1xuICAgICAgICAgICAgaWYgKCFjYWxsYmFja0NhbGxlZCkge1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrQ2FsbGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBvblJlc3VsdChlcnIsIHJlcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIGxldCByZXEgPSBpbmZvLmh0dHBNb2R1bGUucmVxdWVzdChpbmZvLm9wdGlvbnMsIChtc2cpID0+IHtcbiAgICAgICAgICAgIGxldCByZXMgPSBuZXcgSHR0cENsaWVudFJlc3BvbnNlKG1zZyk7XG4gICAgICAgICAgICBoYW5kbGVSZXN1bHQobnVsbCwgcmVzKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJlcS5vbignc29ja2V0JywgKHNvY2spID0+IHtcbiAgICAgICAgICAgIHNvY2tldCA9IHNvY2s7XG4gICAgICAgIH0pO1xuICAgICAgICAvLyBJZiB3ZSBldmVyIGdldCBkaXNjb25uZWN0ZWQsIHdlIHdhbnQgdGhlIHNvY2tldCB0byB0aW1lb3V0IGV2ZW50dWFsbHlcbiAgICAgICAgcmVxLnNldFRpbWVvdXQodGhpcy5fc29ja2V0VGltZW91dCB8fCAzICogNjAwMDAsICgpID0+IHtcbiAgICAgICAgICAgIGlmIChzb2NrZXQpIHtcbiAgICAgICAgICAgICAgICBzb2NrZXQuZGVzdHJveSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaGFuZGxlUmVzdWx0KG5ldyBFcnJvcignUmVxdWVzdCB0aW1lb3V0OiAnICsgaW5mby5vcHRpb25zLnBhdGgpLCBudWxsKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJlcS5vbignZXJyb3InLCBmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgICAgICAvLyBlcnIgaGFzIHN0YXR1c0NvZGUgcHJvcGVydHlcbiAgICAgICAgICAgIC8vIHJlcyBzaG91bGQgaGF2ZSBoZWFkZXJzXG4gICAgICAgICAgICBoYW5kbGVSZXN1bHQoZXJyLCBudWxsKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChkYXRhICYmIHR5cGVvZiAoZGF0YSkgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICByZXEud3JpdGUoZGF0YSwgJ3V0ZjgnKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZGF0YSAmJiB0eXBlb2YgKGRhdGEpICE9PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgZGF0YS5vbignY2xvc2UnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmVxLmVuZCgpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBkYXRhLnBpcGUocmVxKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJlcS5lbmQoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBfcHJlcGFyZVJlcXVlc3QobWV0aG9kLCByZXF1ZXN0VXJsLCBoZWFkZXJzKSB7XG4gICAgICAgIGNvbnN0IGluZm8gPSB7fTtcbiAgICAgICAgaW5mby5wYXJzZWRVcmwgPSByZXF1ZXN0VXJsO1xuICAgICAgICBjb25zdCB1c2luZ1NzbCA9IGluZm8ucGFyc2VkVXJsLnByb3RvY29sID09PSAnaHR0cHM6JztcbiAgICAgICAgaW5mby5odHRwTW9kdWxlID0gdXNpbmdTc2wgPyBodHRwcyA6IGh0dHA7XG4gICAgICAgIGNvbnN0IGRlZmF1bHRQb3J0ID0gdXNpbmdTc2wgPyA0NDMgOiA4MDtcbiAgICAgICAgaW5mby5vcHRpb25zID0ge307XG4gICAgICAgIGluZm8ub3B0aW9ucy5ob3N0ID0gaW5mby5wYXJzZWRVcmwuaG9zdG5hbWU7XG4gICAgICAgIGluZm8ub3B0aW9ucy5wb3J0ID0gaW5mby5wYXJzZWRVcmwucG9ydCA/IHBhcnNlSW50KGluZm8ucGFyc2VkVXJsLnBvcnQpIDogZGVmYXVsdFBvcnQ7XG4gICAgICAgIGluZm8ub3B0aW9ucy5wYXRoID0gKGluZm8ucGFyc2VkVXJsLnBhdGhuYW1lIHx8ICcnKSArIChpbmZvLnBhcnNlZFVybC5zZWFyY2ggfHwgJycpO1xuICAgICAgICBpbmZvLm9wdGlvbnMubWV0aG9kID0gbWV0aG9kO1xuICAgICAgICBpbmZvLm9wdGlvbnMudGltZW91dCA9ICh0aGlzLnJlcXVlc3RPcHRpb25zICYmIHRoaXMucmVxdWVzdE9wdGlvbnMuc29ja2V0VGltZW91dCkgfHwgdGhpcy5fc29ja2V0VGltZW91dDtcbiAgICAgICAgdGhpcy5fc29ja2V0VGltZW91dCA9IGluZm8ub3B0aW9ucy50aW1lb3V0O1xuICAgICAgICBpbmZvLm9wdGlvbnMuaGVhZGVycyA9IHRoaXMuX21lcmdlSGVhZGVycyhoZWFkZXJzKTtcbiAgICAgICAgaWYgKHRoaXMudXNlckFnZW50ICE9IG51bGwpIHtcbiAgICAgICAgICAgIGluZm8ub3B0aW9ucy5oZWFkZXJzW1widXNlci1hZ2VudFwiXSA9IHRoaXMudXNlckFnZW50O1xuICAgICAgICB9XG4gICAgICAgIGluZm8ub3B0aW9ucy5hZ2VudCA9IHRoaXMuX2dldEFnZW50KGluZm8ucGFyc2VkVXJsKTtcbiAgICAgICAgLy8gZ2l2ZXMgaGFuZGxlcnMgYW4gb3Bwb3J0dW5pdHkgdG8gcGFydGljaXBhdGVcbiAgICAgICAgaWYgKHRoaXMuaGFuZGxlcnMgJiYgIXRoaXMuX2lzUHJlc2lnbmVkKHVybC5mb3JtYXQocmVxdWVzdFVybCkpKSB7XG4gICAgICAgICAgICB0aGlzLmhhbmRsZXJzLmZvckVhY2goKGhhbmRsZXIpID0+IHtcbiAgICAgICAgICAgICAgICBoYW5kbGVyLnByZXBhcmVSZXF1ZXN0KGluZm8ub3B0aW9ucyk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaW5mbztcbiAgICB9XG4gICAgX2lzUHJlc2lnbmVkKHJlcXVlc3RVcmwpIHtcbiAgICAgICAgaWYgKHRoaXMucmVxdWVzdE9wdGlvbnMgJiYgdGhpcy5yZXF1ZXN0T3B0aW9ucy5wcmVzaWduZWRVcmxQYXR0ZXJucykge1xuICAgICAgICAgICAgY29uc3QgcGF0dGVybnMgPSB0aGlzLnJlcXVlc3RPcHRpb25zLnByZXNpZ25lZFVybFBhdHRlcm5zO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwYXR0ZXJucy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGlmIChyZXF1ZXN0VXJsLm1hdGNoKHBhdHRlcm5zW2ldKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBfbWVyZ2VIZWFkZXJzKGhlYWRlcnMpIHtcbiAgICAgICAgY29uc3QgbG93ZXJjYXNlS2V5cyA9IG9iaiA9PiBPYmplY3Qua2V5cyhvYmopLnJlZHVjZSgoYywgaykgPT4gKGNbay50b0xvd2VyQ2FzZSgpXSA9IG9ialtrXSwgYyksIHt9KTtcbiAgICAgICAgaWYgKHRoaXMucmVxdWVzdE9wdGlvbnMgJiYgdGhpcy5yZXF1ZXN0T3B0aW9ucy5oZWFkZXJzKSB7XG4gICAgICAgICAgICByZXR1cm4gT2JqZWN0LmFzc2lnbih7fSwgbG93ZXJjYXNlS2V5cyh0aGlzLnJlcXVlc3RPcHRpb25zLmhlYWRlcnMpLCBsb3dlcmNhc2VLZXlzKGhlYWRlcnMpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbG93ZXJjYXNlS2V5cyhoZWFkZXJzIHx8IHt9KTtcbiAgICB9XG4gICAgX2dldEFnZW50KHBhcnNlZFVybCkge1xuICAgICAgICBsZXQgYWdlbnQ7XG4gICAgICAgIGxldCBwcm94eSA9IHRoaXMuX2dldFByb3h5KHBhcnNlZFVybCk7XG4gICAgICAgIGxldCB1c2VQcm94eSA9IHByb3h5LnByb3h5VXJsICYmIHByb3h5LnByb3h5VXJsLmhvc3RuYW1lICYmICF0aGlzLl9pc01hdGNoSW5CeXBhc3NQcm94eUxpc3QocGFyc2VkVXJsKTtcbiAgICAgICAgaWYgKHRoaXMuX2tlZXBBbGl2ZSAmJiB1c2VQcm94eSkge1xuICAgICAgICAgICAgYWdlbnQgPSB0aGlzLl9wcm94eUFnZW50O1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLl9rZWVwQWxpdmUgJiYgIXVzZVByb3h5KSB7XG4gICAgICAgICAgICBhZ2VudCA9IHRoaXMuX2FnZW50O1xuICAgICAgICB9XG4gICAgICAgIC8vIGlmIGFnZW50IGlzIGFscmVhZHkgYXNzaWduZWQgdXNlIHRoYXQgYWdlbnQuXG4gICAgICAgIGlmICghIWFnZW50KSB7XG4gICAgICAgICAgICByZXR1cm4gYWdlbnQ7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdXNpbmdTc2wgPSBwYXJzZWRVcmwucHJvdG9jb2wgPT09ICdodHRwczonO1xuICAgICAgICBsZXQgbWF4U29ja2V0cyA9IDEwMDtcbiAgICAgICAgaWYgKCEhdGhpcy5yZXF1ZXN0T3B0aW9ucykge1xuICAgICAgICAgICAgbWF4U29ja2V0cyA9IHRoaXMucmVxdWVzdE9wdGlvbnMubWF4U29ja2V0cyB8fCBodHRwLmdsb2JhbEFnZW50Lm1heFNvY2tldHM7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHVzZVByb3h5KSB7XG4gICAgICAgICAgICAvLyBJZiB1c2luZyBwcm94eSwgbmVlZCB0dW5uZWxcbiAgICAgICAgICAgIGlmICghdHVubmVsKSB7XG4gICAgICAgICAgICAgICAgdHVubmVsID0gcmVxdWlyZSgndHVubmVsJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBhZ2VudE9wdGlvbnMgPSB7XG4gICAgICAgICAgICAgICAgbWF4U29ja2V0czogbWF4U29ja2V0cyxcbiAgICAgICAgICAgICAgICBrZWVwQWxpdmU6IHRoaXMuX2tlZXBBbGl2ZSxcbiAgICAgICAgICAgICAgICBwcm94eToge1xuICAgICAgICAgICAgICAgICAgICBwcm94eUF1dGg6IHByb3h5LnByb3h5QXV0aCxcbiAgICAgICAgICAgICAgICAgICAgaG9zdDogcHJveHkucHJveHlVcmwuaG9zdG5hbWUsXG4gICAgICAgICAgICAgICAgICAgIHBvcnQ6IHByb3h5LnByb3h5VXJsLnBvcnRcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGxldCB0dW5uZWxBZ2VudDtcbiAgICAgICAgICAgIGNvbnN0IG92ZXJIdHRwcyA9IHByb3h5LnByb3h5VXJsLnByb3RvY29sID09PSAnaHR0cHM6JztcbiAgICAgICAgICAgIGlmICh1c2luZ1NzbCkge1xuICAgICAgICAgICAgICAgIHR1bm5lbEFnZW50ID0gb3Zlckh0dHBzID8gdHVubmVsLmh0dHBzT3Zlckh0dHBzIDogdHVubmVsLmh0dHBzT3Zlckh0dHA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0dW5uZWxBZ2VudCA9IG92ZXJIdHRwcyA/IHR1bm5lbC5odHRwT3Zlckh0dHBzIDogdHVubmVsLmh0dHBPdmVySHR0cDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGFnZW50ID0gdHVubmVsQWdlbnQoYWdlbnRPcHRpb25zKTtcbiAgICAgICAgICAgIHRoaXMuX3Byb3h5QWdlbnQgPSBhZ2VudDtcbiAgICAgICAgfVxuICAgICAgICAvLyBpZiByZXVzaW5nIGFnZW50IGFjcm9zcyByZXF1ZXN0IGFuZCB0dW5uZWxpbmcgYWdlbnQgaXNuJ3QgYXNzaWduZWQgY3JlYXRlIGEgbmV3IGFnZW50XG4gICAgICAgIGlmICh0aGlzLl9rZWVwQWxpdmUgJiYgIWFnZW50KSB7XG4gICAgICAgICAgICBjb25zdCBvcHRpb25zID0geyBrZWVwQWxpdmU6IHRoaXMuX2tlZXBBbGl2ZSwgbWF4U29ja2V0czogbWF4U29ja2V0cyB9O1xuICAgICAgICAgICAgYWdlbnQgPSB1c2luZ1NzbCA/IG5ldyBodHRwcy5BZ2VudChvcHRpb25zKSA6IG5ldyBodHRwLkFnZW50KG9wdGlvbnMpO1xuICAgICAgICAgICAgdGhpcy5fYWdlbnQgPSBhZ2VudDtcbiAgICAgICAgfVxuICAgICAgICAvLyBpZiBub3QgdXNpbmcgcHJpdmF0ZSBhZ2VudCBhbmQgdHVubmVsIGFnZW50IGlzbid0IHNldHVwIHRoZW4gdXNlIGdsb2JhbCBhZ2VudFxuICAgICAgICBpZiAoIWFnZW50KSB7XG4gICAgICAgICAgICBjb25zdCBnbG9iYWxBZ2VudE9wdGlvbnMgPSB7XG4gICAgICAgICAgICAgICAga2VlcEFsaXZlOiB0aGlzLl9odHRwR2xvYmFsQWdlbnRPcHRpb25zLmtlZXBBbGl2ZSxcbiAgICAgICAgICAgICAgICB0aW1lb3V0OiB0aGlzLl9odHRwR2xvYmFsQWdlbnRPcHRpb25zLnRpbWVvdXRcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBhZ2VudCA9IHVzaW5nU3NsID8gbmV3IGh0dHBzLkFnZW50KGdsb2JhbEFnZW50T3B0aW9ucykgOiBuZXcgaHR0cC5BZ2VudChnbG9iYWxBZ2VudE9wdGlvbnMpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh1c2luZ1NzbCAmJiB0aGlzLl9pZ25vcmVTc2xFcnJvcikge1xuICAgICAgICAgICAgLy8gd2UgZG9uJ3Qgd2FudCB0byBzZXQgTk9ERV9UTFNfUkVKRUNUX1VOQVVUSE9SSVpFRD0wIHNpbmNlIHRoYXQgd2lsbCBhZmZlY3QgcmVxdWVzdCBmb3IgZW50aXJlIHByb2Nlc3NcbiAgICAgICAgICAgIC8vIGh0dHAuUmVxdWVzdE9wdGlvbnMgZG9lc24ndCBleHBvc2UgYSB3YXkgdG8gbW9kaWZ5IFJlcXVlc3RPcHRpb25zLmFnZW50Lm9wdGlvbnNcbiAgICAgICAgICAgIC8vIHdlIGhhdmUgdG8gY2FzdCBpdCB0byBhbnkgYW5kIGNoYW5nZSBpdCBkaXJlY3RseVxuICAgICAgICAgICAgYWdlbnQub3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oYWdlbnQub3B0aW9ucyB8fCB7fSwgeyByZWplY3RVbmF1dGhvcml6ZWQ6IGZhbHNlIH0pO1xuICAgICAgICB9XG4gICAgICAgIGlmICh1c2luZ1NzbCAmJiB0aGlzLl9jZXJ0Q29uZmlnKSB7XG4gICAgICAgICAgICBhZ2VudC5vcHRpb25zID0gT2JqZWN0LmFzc2lnbihhZ2VudC5vcHRpb25zIHx8IHt9LCB7IGNhOiB0aGlzLl9jYSwgY2VydDogdGhpcy5fY2VydCwga2V5OiB0aGlzLl9rZXksIHBhc3NwaHJhc2U6IHRoaXMuX2NlcnRDb25maWcucGFzc3BocmFzZSB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYWdlbnQ7XG4gICAgfVxuICAgIF9nZXRQcm94eShwYXJzZWRVcmwpIHtcbiAgICAgICAgbGV0IHVzaW5nU3NsID0gcGFyc2VkVXJsLnByb3RvY29sID09PSAnaHR0cHM6JztcbiAgICAgICAgbGV0IHByb3h5Q29uZmlnID0gdGhpcy5faHR0cFByb3h5O1xuICAgICAgICAvLyBmYWxsYmFjayB0byBodHRwX3Byb3h5IGFuZCBodHRwc19wcm94eSBlbnZcbiAgICAgICAgbGV0IGh0dHBzX3Byb3h5ID0gcHJvY2Vzcy5lbnZbRW52aXJvbm1lbnRWYXJpYWJsZXMuSFRUUFNfUFJPWFldO1xuICAgICAgICBsZXQgaHR0cF9wcm94eSA9IHByb2Nlc3MuZW52W0Vudmlyb25tZW50VmFyaWFibGVzLkhUVFBfUFJPWFldO1xuICAgICAgICBpZiAoIXByb3h5Q29uZmlnKSB7XG4gICAgICAgICAgICBpZiAoaHR0cHNfcHJveHkgJiYgdXNpbmdTc2wpIHtcbiAgICAgICAgICAgICAgICBwcm94eUNvbmZpZyA9IHtcbiAgICAgICAgICAgICAgICAgICAgcHJveHlVcmw6IGh0dHBzX3Byb3h5XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGh0dHBfcHJveHkpIHtcbiAgICAgICAgICAgICAgICBwcm94eUNvbmZpZyA9IHtcbiAgICAgICAgICAgICAgICAgICAgcHJveHlVcmw6IGh0dHBfcHJveHlcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGxldCBwcm94eVVybDtcbiAgICAgICAgbGV0IHByb3h5QXV0aDtcbiAgICAgICAgaWYgKHByb3h5Q29uZmlnKSB7XG4gICAgICAgICAgICBpZiAocHJveHlDb25maWcucHJveHlVcmwubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIHByb3h5VXJsID0gdXJsLnBhcnNlKHByb3h5Q29uZmlnLnByb3h5VXJsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChwcm94eUNvbmZpZy5wcm94eVVzZXJuYW1lIHx8IHByb3h5Q29uZmlnLnByb3h5UGFzc3dvcmQpIHtcbiAgICAgICAgICAgICAgICBwcm94eUF1dGggPSBwcm94eUNvbmZpZy5wcm94eVVzZXJuYW1lICsgXCI6XCIgKyBwcm94eUNvbmZpZy5wcm94eVBhc3N3b3JkO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7IHByb3h5VXJsOiBwcm94eVVybCwgcHJveHlBdXRoOiBwcm94eUF1dGggfTtcbiAgICB9XG4gICAgX2lzTWF0Y2hJbkJ5cGFzc1Byb3h5TGlzdChwYXJzZWRVcmwpIHtcbiAgICAgICAgaWYgKCF0aGlzLl9odHRwUHJveHlCeXBhc3NIb3N0cykge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGxldCBieXBhc3MgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5faHR0cFByb3h5QnlwYXNzSG9zdHMuZm9yRWFjaChieXBhc3NIb3N0ID0+IHtcbiAgICAgICAgICAgIGlmIChieXBhc3NIb3N0LnRlc3QocGFyc2VkVXJsLmhyZWYpKSB7XG4gICAgICAgICAgICAgICAgYnlwYXNzID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBieXBhc3M7XG4gICAgfVxuICAgIF9wZXJmb3JtRXhwb25lbnRpYWxCYWNrb2ZmKHJldHJ5TnVtYmVyKSB7XG4gICAgICAgIHJldHJ5TnVtYmVyID0gTWF0aC5taW4oRXhwb25lbnRpYWxCYWNrb2ZmQ2VpbGluZywgcmV0cnlOdW1iZXIpO1xuICAgICAgICBjb25zdCBtcyA9IEV4cG9uZW50aWFsQmFja29mZlRpbWVTbGljZSAqIE1hdGgucG93KDIsIHJldHJ5TnVtYmVyKTtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKHJlc29sdmUgPT4gc2V0VGltZW91dCgoKSA9PiByZXNvbHZlKCksIG1zKSk7XG4gICAgfVxufVxuZXhwb3J0cy5IdHRwQ2xpZW50ID0gSHR0cENsaWVudDtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/typed-rest-client/HttpClient.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/typed-rest-client/RestClient.js":
/*!******************************************************!*\
  !*** ./node_modules/typed-rest-client/RestClient.js ***!
  \******************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\n// Copyright (c) Microsoft. All rights reserved.\n// Licensed under the MIT license. See LICENSE file in the project root for full license information.\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.RestClient = void 0;\nconst httpm = __webpack_require__(/*! ./HttpClient */ \"(rsc)/./node_modules/typed-rest-client/HttpClient.js\");\nconst util = __webpack_require__(/*! ./Util */ \"(rsc)/./node_modules/typed-rest-client/Util.js\");\nclass RestClient {\n    /**\n     * Creates an instance of the RestClient\n     * @constructor\n     * @param {string} userAgent - userAgent for requests\n     * @param {string} baseUrl - (Optional) If not specified, use full urls per request.  If supplied and a function passes a relative url, it will be appended to this\n     * @param {ifm.IRequestHandler[]} handlers - handlers are typically auth handlers (basic, bearer, ntlm supplied)\n     * @param {ifm.IRequestOptions} requestOptions - options for each http requests (http proxy setting, socket timeout)\n     */\n    constructor(userAgent, baseUrl, handlers, requestOptions) {\n        this.client = new httpm.HttpClient(userAgent, handlers, requestOptions);\n        if (baseUrl) {\n            this._baseUrl = baseUrl;\n        }\n    }\n    /**\n     * Gets a resource from an endpoint\n     * Be aware that not found returns a null.  Other error conditions reject the promise\n     * @param {string} requestUrl - fully qualified or relative url\n     * @param {IRequestOptions} requestOptions - (optional) requestOptions object\n     */\n    options(requestUrl, options) {\n        return __awaiter(this, void 0, void 0, function* () {\n            let url = util.getUrl(requestUrl, this._baseUrl);\n            let res = yield this.client.options(url, this._headersFromOptions(options));\n            return this.processResponse(res, options);\n        });\n    }\n    /**\n     * Gets a resource from an endpoint\n     * Be aware that not found returns a null.  Other error conditions reject the promise\n     * @param {string} resource - fully qualified url or relative path\n     * @param {IRequestOptions} requestOptions - (optional) requestOptions object\n     */\n    get(resource, options) {\n        return __awaiter(this, void 0, void 0, function* () {\n            let url = util.getUrl(resource, this._baseUrl, (options || {}).queryParameters);\n            let res = yield this.client.get(url, this._headersFromOptions(options));\n            return this.processResponse(res, options);\n        });\n    }\n    /**\n     * Deletes a resource from an endpoint\n     * Be aware that not found returns a null.  Other error conditions reject the promise\n     * @param {string} resource - fully qualified or relative url\n     * @param {IRequestOptions} requestOptions - (optional) requestOptions object\n     */\n    del(resource, options) {\n        return __awaiter(this, void 0, void 0, function* () {\n            let url = util.getUrl(resource, this._baseUrl, (options || {}).queryParameters);\n            let res = yield this.client.del(url, this._headersFromOptions(options));\n            return this.processResponse(res, options);\n        });\n    }\n    /**\n     * Creates resource(s) from an endpoint\n     * T type of object returned.\n     * Be aware that not found returns a null.  Other error conditions reject the promise\n     * @param {string} resource - fully qualified or relative url\n     * @param {IRequestOptions} requestOptions - (optional) requestOptions object\n     */\n    create(resource, resources, options) {\n        return __awaiter(this, void 0, void 0, function* () {\n            let url = util.getUrl(resource, this._baseUrl);\n            let headers = this._headersFromOptions(options, true);\n            let data = JSON.stringify(resources, null, 2);\n            let res = yield this.client.post(url, data, headers);\n            return this.processResponse(res, options);\n        });\n    }\n    /**\n     * Updates resource(s) from an endpoint\n     * T type of object returned.\n     * Be aware that not found returns a null.  Other error conditions reject the promise\n     * @param {string} resource - fully qualified or relative url\n     * @param {IRequestOptions} requestOptions - (optional) requestOptions object\n     */\n    update(resource, resources, options) {\n        return __awaiter(this, void 0, void 0, function* () {\n            let url = util.getUrl(resource, this._baseUrl);\n            let headers = this._headersFromOptions(options, true);\n            let data = JSON.stringify(resources, null, 2);\n            let res = yield this.client.patch(url, data, headers);\n            return this.processResponse(res, options);\n        });\n    }\n    /**\n     * Replaces resource(s) from an endpoint\n     * T type of object returned.\n     * Be aware that not found returns a null.  Other error conditions reject the promise\n     * @param {string} resource - fully qualified or relative url\n     * @param {IRequestOptions} requestOptions - (optional) requestOptions object\n     */\n    replace(resource, resources, options) {\n        return __awaiter(this, void 0, void 0, function* () {\n            let url = util.getUrl(resource, this._baseUrl);\n            let headers = this._headersFromOptions(options, true);\n            let data = JSON.stringify(resources, null, 2);\n            let res = yield this.client.put(url, data, headers);\n            return this.processResponse(res, options);\n        });\n    }\n    uploadStream(verb, requestUrl, stream, options) {\n        return __awaiter(this, void 0, void 0, function* () {\n            let url = util.getUrl(requestUrl, this._baseUrl);\n            let headers = this._headersFromOptions(options, true);\n            let res = yield this.client.sendStream(verb, url, stream, headers);\n            return this.processResponse(res, options);\n        });\n    }\n    _headersFromOptions(options, contentType) {\n        options = options || {};\n        let headers = options.additionalHeaders || {};\n        headers[\"Accept\"] = options.acceptHeader || \"application/json\";\n        if (contentType) {\n            let found = false;\n            for (let header in headers) {\n                if (header.toLowerCase() == \"content-type\") {\n                    found = true;\n                }\n            }\n            if (!found) {\n                headers[\"Content-Type\"] = 'application/json; charset=utf-8';\n            }\n        }\n        return headers;\n    }\n    static dateTimeDeserializer(key, value) {\n        if (typeof value === 'string') {\n            let a = new Date(value);\n            if (!isNaN(a.valueOf())) {\n                return a;\n            }\n        }\n        return value;\n    }\n    processResponse(res, options) {\n        return __awaiter(this, void 0, void 0, function* () {\n            return new Promise((resolve, reject) => __awaiter(this, void 0, void 0, function* () {\n                const statusCode = res.message.statusCode;\n                const response = {\n                    statusCode: statusCode,\n                    result: null,\n                    headers: {}\n                };\n                // not found leads to null obj returned\n                if (statusCode == httpm.HttpCodes.NotFound) {\n                    resolve(response);\n                }\n                let obj;\n                let contents;\n                // get the result from the body\n                try {\n                    contents = yield res.readBody();\n                    if (contents && contents.length > 0) {\n                        if (options && options.deserializeDates) {\n                            obj = JSON.parse(contents, RestClient.dateTimeDeserializer);\n                        }\n                        else {\n                            obj = JSON.parse(contents);\n                        }\n                        if (options && options.responseProcessor) {\n                            response.result = options.responseProcessor(obj);\n                        }\n                        else {\n                            response.result = obj;\n                        }\n                    }\n                    response.headers = res.message.headers;\n                }\n                catch (err) {\n                    // Invalid resource (contents not json);  leaving result obj null\n                }\n                // note that 3xx redirects are handled by the http layer.\n                if (statusCode > 299) {\n                    let msg;\n                    // if exception/error in body, attempt to get better error\n                    if (obj && obj.message) {\n                        msg = obj.message;\n                    }\n                    else if (contents && contents.length > 0) {\n                        // it may be the case that the exception is in the body message as string\n                        msg = contents;\n                    }\n                    else {\n                        msg = \"Failed request: (\" + statusCode + \")\";\n                    }\n                    let err = new Error(msg);\n                    // attach statusCode and body obj (if available) to the error object\n                    err['statusCode'] = statusCode;\n                    if (response.result) {\n                        err['result'] = response.result;\n                    }\n                    if (response.headers) {\n                        err['responseHeaders'] = response.headers;\n                    }\n                    reject(err);\n                }\n                else {\n                    resolve(response);\n                }\n            }));\n        });\n    }\n}\nexports.RestClient = RestClient;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvdHlwZWQtcmVzdC1jbGllbnQvUmVzdENsaWVudC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QiwrREFBK0QsaUJBQWlCO0FBQzVHO0FBQ0Esb0NBQW9DLE1BQU0sK0JBQStCLFlBQVk7QUFDckYsbUNBQW1DLE1BQU0sbUNBQW1DLFlBQVk7QUFDeEYsZ0NBQWdDO0FBQ2hDO0FBQ0EsS0FBSztBQUNMO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELGtCQUFrQjtBQUNsQixjQUFjLG1CQUFPLENBQUMsMEVBQWM7QUFDcEMsYUFBYSxtQkFBTyxDQUFDLDhEQUFRO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QixlQUFlLHVCQUF1QjtBQUN0QyxlQUFlLHFCQUFxQjtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixlQUFlLGlCQUFpQjtBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsZUFBZSxpQkFBaUI7QUFDaEM7QUFDQTtBQUNBO0FBQ0EseUVBQXlFO0FBQ3pFO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsZUFBZSxpQkFBaUI7QUFDaEM7QUFDQTtBQUNBO0FBQ0EseUVBQXlFO0FBQ3pFO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixlQUFlLGlCQUFpQjtBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsZUFBZSxpQkFBaUI7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsaUJBQWlCO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2REFBNkQ7QUFDN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOERBQThEO0FBQzlEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQSxrQkFBa0IiLCJzb3VyY2VzIjpbIkM6XFxQcm9qZWN0c1xcQnVpbGRMYXVuY2hlclRlc3RcXG5vZGVfbW9kdWxlc1xcdHlwZWQtcmVzdC1jbGllbnRcXFJlc3RDbGllbnQuanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG4vLyBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdC4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZS4gU2VlIExJQ0VOU0UgZmlsZSBpbiB0aGUgcHJvamVjdCByb290IGZvciBmdWxsIGxpY2Vuc2UgaW5mb3JtYXRpb24uXG52YXIgX19hd2FpdGVyID0gKHRoaXMgJiYgdGhpcy5fX2F3YWl0ZXIpIHx8IGZ1bmN0aW9uICh0aGlzQXJnLCBfYXJndW1lbnRzLCBQLCBnZW5lcmF0b3IpIHtcbiAgICBmdW5jdGlvbiBhZG9wdCh2YWx1ZSkgeyByZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBQID8gdmFsdWUgOiBuZXcgUChmdW5jdGlvbiAocmVzb2x2ZSkgeyByZXNvbHZlKHZhbHVlKTsgfSk7IH1cbiAgICByZXR1cm4gbmV3IChQIHx8IChQID0gUHJvbWlzZSkpKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgZnVuY3Rpb24gZnVsZmlsbGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yLm5leHQodmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxuICAgICAgICBmdW5jdGlvbiByZWplY3RlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvcltcInRocm93XCJdKHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cbiAgICAgICAgZnVuY3Rpb24gc3RlcChyZXN1bHQpIHsgcmVzdWx0LmRvbmUgPyByZXNvbHZlKHJlc3VsdC52YWx1ZSkgOiBhZG9wdChyZXN1bHQudmFsdWUpLnRoZW4oZnVsZmlsbGVkLCByZWplY3RlZCk7IH1cbiAgICAgICAgc3RlcCgoZ2VuZXJhdG9yID0gZ2VuZXJhdG9yLmFwcGx5KHRoaXNBcmcsIF9hcmd1bWVudHMgfHwgW10pKS5uZXh0KCkpO1xuICAgIH0pO1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuUmVzdENsaWVudCA9IHZvaWQgMDtcbmNvbnN0IGh0dHBtID0gcmVxdWlyZShcIi4vSHR0cENsaWVudFwiKTtcbmNvbnN0IHV0aWwgPSByZXF1aXJlKFwiLi9VdGlsXCIpO1xuY2xhc3MgUmVzdENsaWVudCB7XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiBpbnN0YW5jZSBvZiB0aGUgUmVzdENsaWVudFxuICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB1c2VyQWdlbnQgLSB1c2VyQWdlbnQgZm9yIHJlcXVlc3RzXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGJhc2VVcmwgLSAoT3B0aW9uYWwpIElmIG5vdCBzcGVjaWZpZWQsIHVzZSBmdWxsIHVybHMgcGVyIHJlcXVlc3QuICBJZiBzdXBwbGllZCBhbmQgYSBmdW5jdGlvbiBwYXNzZXMgYSByZWxhdGl2ZSB1cmwsIGl0IHdpbGwgYmUgYXBwZW5kZWQgdG8gdGhpc1xuICAgICAqIEBwYXJhbSB7aWZtLklSZXF1ZXN0SGFuZGxlcltdfSBoYW5kbGVycyAtIGhhbmRsZXJzIGFyZSB0eXBpY2FsbHkgYXV0aCBoYW5kbGVycyAoYmFzaWMsIGJlYXJlciwgbnRsbSBzdXBwbGllZClcbiAgICAgKiBAcGFyYW0ge2lmbS5JUmVxdWVzdE9wdGlvbnN9IHJlcXVlc3RPcHRpb25zIC0gb3B0aW9ucyBmb3IgZWFjaCBodHRwIHJlcXVlc3RzIChodHRwIHByb3h5IHNldHRpbmcsIHNvY2tldCB0aW1lb3V0KVxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKHVzZXJBZ2VudCwgYmFzZVVybCwgaGFuZGxlcnMsIHJlcXVlc3RPcHRpb25zKSB7XG4gICAgICAgIHRoaXMuY2xpZW50ID0gbmV3IGh0dHBtLkh0dHBDbGllbnQodXNlckFnZW50LCBoYW5kbGVycywgcmVxdWVzdE9wdGlvbnMpO1xuICAgICAgICBpZiAoYmFzZVVybCkge1xuICAgICAgICAgICAgdGhpcy5fYmFzZVVybCA9IGJhc2VVcmw7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0cyBhIHJlc291cmNlIGZyb20gYW4gZW5kcG9pbnRcbiAgICAgKiBCZSBhd2FyZSB0aGF0IG5vdCBmb3VuZCByZXR1cm5zIGEgbnVsbC4gIE90aGVyIGVycm9yIGNvbmRpdGlvbnMgcmVqZWN0IHRoZSBwcm9taXNlXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHJlcXVlc3RVcmwgLSBmdWxseSBxdWFsaWZpZWQgb3IgcmVsYXRpdmUgdXJsXG4gICAgICogQHBhcmFtIHtJUmVxdWVzdE9wdGlvbnN9IHJlcXVlc3RPcHRpb25zIC0gKG9wdGlvbmFsKSByZXF1ZXN0T3B0aW9ucyBvYmplY3RcbiAgICAgKi9cbiAgICBvcHRpb25zKHJlcXVlc3RVcmwsIG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGxldCB1cmwgPSB1dGlsLmdldFVybChyZXF1ZXN0VXJsLCB0aGlzLl9iYXNlVXJsKTtcbiAgICAgICAgICAgIGxldCByZXMgPSB5aWVsZCB0aGlzLmNsaWVudC5vcHRpb25zKHVybCwgdGhpcy5faGVhZGVyc0Zyb21PcHRpb25zKG9wdGlvbnMpKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnByb2Nlc3NSZXNwb25zZShyZXMsIG9wdGlvbnMpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0cyBhIHJlc291cmNlIGZyb20gYW4gZW5kcG9pbnRcbiAgICAgKiBCZSBhd2FyZSB0aGF0IG5vdCBmb3VuZCByZXR1cm5zIGEgbnVsbC4gIE90aGVyIGVycm9yIGNvbmRpdGlvbnMgcmVqZWN0IHRoZSBwcm9taXNlXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHJlc291cmNlIC0gZnVsbHkgcXVhbGlmaWVkIHVybCBvciByZWxhdGl2ZSBwYXRoXG4gICAgICogQHBhcmFtIHtJUmVxdWVzdE9wdGlvbnN9IHJlcXVlc3RPcHRpb25zIC0gKG9wdGlvbmFsKSByZXF1ZXN0T3B0aW9ucyBvYmplY3RcbiAgICAgKi9cbiAgICBnZXQocmVzb3VyY2UsIG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGxldCB1cmwgPSB1dGlsLmdldFVybChyZXNvdXJjZSwgdGhpcy5fYmFzZVVybCwgKG9wdGlvbnMgfHwge30pLnF1ZXJ5UGFyYW1ldGVycyk7XG4gICAgICAgICAgICBsZXQgcmVzID0geWllbGQgdGhpcy5jbGllbnQuZ2V0KHVybCwgdGhpcy5faGVhZGVyc0Zyb21PcHRpb25zKG9wdGlvbnMpKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnByb2Nlc3NSZXNwb25zZShyZXMsIG9wdGlvbnMpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRGVsZXRlcyBhIHJlc291cmNlIGZyb20gYW4gZW5kcG9pbnRcbiAgICAgKiBCZSBhd2FyZSB0aGF0IG5vdCBmb3VuZCByZXR1cm5zIGEgbnVsbC4gIE90aGVyIGVycm9yIGNvbmRpdGlvbnMgcmVqZWN0IHRoZSBwcm9taXNlXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHJlc291cmNlIC0gZnVsbHkgcXVhbGlmaWVkIG9yIHJlbGF0aXZlIHVybFxuICAgICAqIEBwYXJhbSB7SVJlcXVlc3RPcHRpb25zfSByZXF1ZXN0T3B0aW9ucyAtIChvcHRpb25hbCkgcmVxdWVzdE9wdGlvbnMgb2JqZWN0XG4gICAgICovXG4gICAgZGVsKHJlc291cmNlLCBvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBsZXQgdXJsID0gdXRpbC5nZXRVcmwocmVzb3VyY2UsIHRoaXMuX2Jhc2VVcmwsIChvcHRpb25zIHx8IHt9KS5xdWVyeVBhcmFtZXRlcnMpO1xuICAgICAgICAgICAgbGV0IHJlcyA9IHlpZWxkIHRoaXMuY2xpZW50LmRlbCh1cmwsIHRoaXMuX2hlYWRlcnNGcm9tT3B0aW9ucyhvcHRpb25zKSk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5wcm9jZXNzUmVzcG9uc2UocmVzLCBvcHRpb25zKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgcmVzb3VyY2UocykgZnJvbSBhbiBlbmRwb2ludFxuICAgICAqIFQgdHlwZSBvZiBvYmplY3QgcmV0dXJuZWQuXG4gICAgICogQmUgYXdhcmUgdGhhdCBub3QgZm91bmQgcmV0dXJucyBhIG51bGwuICBPdGhlciBlcnJvciBjb25kaXRpb25zIHJlamVjdCB0aGUgcHJvbWlzZVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSByZXNvdXJjZSAtIGZ1bGx5IHF1YWxpZmllZCBvciByZWxhdGl2ZSB1cmxcbiAgICAgKiBAcGFyYW0ge0lSZXF1ZXN0T3B0aW9uc30gcmVxdWVzdE9wdGlvbnMgLSAob3B0aW9uYWwpIHJlcXVlc3RPcHRpb25zIG9iamVjdFxuICAgICAqL1xuICAgIGNyZWF0ZShyZXNvdXJjZSwgcmVzb3VyY2VzLCBvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBsZXQgdXJsID0gdXRpbC5nZXRVcmwocmVzb3VyY2UsIHRoaXMuX2Jhc2VVcmwpO1xuICAgICAgICAgICAgbGV0IGhlYWRlcnMgPSB0aGlzLl9oZWFkZXJzRnJvbU9wdGlvbnMob3B0aW9ucywgdHJ1ZSk7XG4gICAgICAgICAgICBsZXQgZGF0YSA9IEpTT04uc3RyaW5naWZ5KHJlc291cmNlcywgbnVsbCwgMik7XG4gICAgICAgICAgICBsZXQgcmVzID0geWllbGQgdGhpcy5jbGllbnQucG9zdCh1cmwsIGRhdGEsIGhlYWRlcnMpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucHJvY2Vzc1Jlc3BvbnNlKHJlcywgb3B0aW9ucyk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBVcGRhdGVzIHJlc291cmNlKHMpIGZyb20gYW4gZW5kcG9pbnRcbiAgICAgKiBUIHR5cGUgb2Ygb2JqZWN0IHJldHVybmVkLlxuICAgICAqIEJlIGF3YXJlIHRoYXQgbm90IGZvdW5kIHJldHVybnMgYSBudWxsLiAgT3RoZXIgZXJyb3IgY29uZGl0aW9ucyByZWplY3QgdGhlIHByb21pc2VcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gcmVzb3VyY2UgLSBmdWxseSBxdWFsaWZpZWQgb3IgcmVsYXRpdmUgdXJsXG4gICAgICogQHBhcmFtIHtJUmVxdWVzdE9wdGlvbnN9IHJlcXVlc3RPcHRpb25zIC0gKG9wdGlvbmFsKSByZXF1ZXN0T3B0aW9ucyBvYmplY3RcbiAgICAgKi9cbiAgICB1cGRhdGUocmVzb3VyY2UsIHJlc291cmNlcywgb3B0aW9ucykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgbGV0IHVybCA9IHV0aWwuZ2V0VXJsKHJlc291cmNlLCB0aGlzLl9iYXNlVXJsKTtcbiAgICAgICAgICAgIGxldCBoZWFkZXJzID0gdGhpcy5faGVhZGVyc0Zyb21PcHRpb25zKG9wdGlvbnMsIHRydWUpO1xuICAgICAgICAgICAgbGV0IGRhdGEgPSBKU09OLnN0cmluZ2lmeShyZXNvdXJjZXMsIG51bGwsIDIpO1xuICAgICAgICAgICAgbGV0IHJlcyA9IHlpZWxkIHRoaXMuY2xpZW50LnBhdGNoKHVybCwgZGF0YSwgaGVhZGVycyk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5wcm9jZXNzUmVzcG9uc2UocmVzLCBvcHRpb25zKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlcGxhY2VzIHJlc291cmNlKHMpIGZyb20gYW4gZW5kcG9pbnRcbiAgICAgKiBUIHR5cGUgb2Ygb2JqZWN0IHJldHVybmVkLlxuICAgICAqIEJlIGF3YXJlIHRoYXQgbm90IGZvdW5kIHJldHVybnMgYSBudWxsLiAgT3RoZXIgZXJyb3IgY29uZGl0aW9ucyByZWplY3QgdGhlIHByb21pc2VcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gcmVzb3VyY2UgLSBmdWxseSBxdWFsaWZpZWQgb3IgcmVsYXRpdmUgdXJsXG4gICAgICogQHBhcmFtIHtJUmVxdWVzdE9wdGlvbnN9IHJlcXVlc3RPcHRpb25zIC0gKG9wdGlvbmFsKSByZXF1ZXN0T3B0aW9ucyBvYmplY3RcbiAgICAgKi9cbiAgICByZXBsYWNlKHJlc291cmNlLCByZXNvdXJjZXMsIG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGxldCB1cmwgPSB1dGlsLmdldFVybChyZXNvdXJjZSwgdGhpcy5fYmFzZVVybCk7XG4gICAgICAgICAgICBsZXQgaGVhZGVycyA9IHRoaXMuX2hlYWRlcnNGcm9tT3B0aW9ucyhvcHRpb25zLCB0cnVlKTtcbiAgICAgICAgICAgIGxldCBkYXRhID0gSlNPTi5zdHJpbmdpZnkocmVzb3VyY2VzLCBudWxsLCAyKTtcbiAgICAgICAgICAgIGxldCByZXMgPSB5aWVsZCB0aGlzLmNsaWVudC5wdXQodXJsLCBkYXRhLCBoZWFkZXJzKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnByb2Nlc3NSZXNwb25zZShyZXMsIG9wdGlvbnMpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgdXBsb2FkU3RyZWFtKHZlcmIsIHJlcXVlc3RVcmwsIHN0cmVhbSwgb3B0aW9ucykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgbGV0IHVybCA9IHV0aWwuZ2V0VXJsKHJlcXVlc3RVcmwsIHRoaXMuX2Jhc2VVcmwpO1xuICAgICAgICAgICAgbGV0IGhlYWRlcnMgPSB0aGlzLl9oZWFkZXJzRnJvbU9wdGlvbnMob3B0aW9ucywgdHJ1ZSk7XG4gICAgICAgICAgICBsZXQgcmVzID0geWllbGQgdGhpcy5jbGllbnQuc2VuZFN0cmVhbSh2ZXJiLCB1cmwsIHN0cmVhbSwgaGVhZGVycyk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5wcm9jZXNzUmVzcG9uc2UocmVzLCBvcHRpb25zKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIF9oZWFkZXJzRnJvbU9wdGlvbnMob3B0aW9ucywgY29udGVudFR5cGUpIHtcbiAgICAgICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gICAgICAgIGxldCBoZWFkZXJzID0gb3B0aW9ucy5hZGRpdGlvbmFsSGVhZGVycyB8fCB7fTtcbiAgICAgICAgaGVhZGVyc1tcIkFjY2VwdFwiXSA9IG9wdGlvbnMuYWNjZXB0SGVhZGVyIHx8IFwiYXBwbGljYXRpb24vanNvblwiO1xuICAgICAgICBpZiAoY29udGVudFR5cGUpIHtcbiAgICAgICAgICAgIGxldCBmb3VuZCA9IGZhbHNlO1xuICAgICAgICAgICAgZm9yIChsZXQgaGVhZGVyIGluIGhlYWRlcnMpIHtcbiAgICAgICAgICAgICAgICBpZiAoaGVhZGVyLnRvTG93ZXJDYXNlKCkgPT0gXCJjb250ZW50LXR5cGVcIikge1xuICAgICAgICAgICAgICAgICAgICBmb3VuZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFmb3VuZCkge1xuICAgICAgICAgICAgICAgIGhlYWRlcnNbXCJDb250ZW50LVR5cGVcIl0gPSAnYXBwbGljYXRpb24vanNvbjsgY2hhcnNldD11dGYtOCc7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGhlYWRlcnM7XG4gICAgfVxuICAgIHN0YXRpYyBkYXRlVGltZURlc2VyaWFsaXplcihrZXksIHZhbHVlKSB7XG4gICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICBsZXQgYSA9IG5ldyBEYXRlKHZhbHVlKTtcbiAgICAgICAgICAgIGlmICghaXNOYU4oYS52YWx1ZU9mKCkpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGE7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cbiAgICBwcm9jZXNzUmVzcG9uc2UocmVzLCBvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHN0YXR1c0NvZGUgPSByZXMubWVzc2FnZS5zdGF0dXNDb2RlO1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0ge1xuICAgICAgICAgICAgICAgICAgICBzdGF0dXNDb2RlOiBzdGF0dXNDb2RlLFxuICAgICAgICAgICAgICAgICAgICByZXN1bHQ6IG51bGwsXG4gICAgICAgICAgICAgICAgICAgIGhlYWRlcnM6IHt9XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAvLyBub3QgZm91bmQgbGVhZHMgdG8gbnVsbCBvYmogcmV0dXJuZWRcbiAgICAgICAgICAgICAgICBpZiAoc3RhdHVzQ29kZSA9PSBodHRwbS5IdHRwQ29kZXMuTm90Rm91bmQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZShyZXNwb25zZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGxldCBvYmo7XG4gICAgICAgICAgICAgICAgbGV0IGNvbnRlbnRzO1xuICAgICAgICAgICAgICAgIC8vIGdldCB0aGUgcmVzdWx0IGZyb20gdGhlIGJvZHlcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBjb250ZW50cyA9IHlpZWxkIHJlcy5yZWFkQm9keSgpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoY29udGVudHMgJiYgY29udGVudHMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG9wdGlvbnMgJiYgb3B0aW9ucy5kZXNlcmlhbGl6ZURhdGVzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb2JqID0gSlNPTi5wYXJzZShjb250ZW50cywgUmVzdENsaWVudC5kYXRlVGltZURlc2VyaWFsaXplcik7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvYmogPSBKU09OLnBhcnNlKGNvbnRlbnRzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChvcHRpb25zICYmIG9wdGlvbnMucmVzcG9uc2VQcm9jZXNzb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXNwb25zZS5yZXN1bHQgPSBvcHRpb25zLnJlc3BvbnNlUHJvY2Vzc29yKG9iaik7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXNwb25zZS5yZXN1bHQgPSBvYmo7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmVzcG9uc2UuaGVhZGVycyA9IHJlcy5tZXNzYWdlLmhlYWRlcnM7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gSW52YWxpZCByZXNvdXJjZSAoY29udGVudHMgbm90IGpzb24pOyAgbGVhdmluZyByZXN1bHQgb2JqIG51bGxcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gbm90ZSB0aGF0IDN4eCByZWRpcmVjdHMgYXJlIGhhbmRsZWQgYnkgdGhlIGh0dHAgbGF5ZXIuXG4gICAgICAgICAgICAgICAgaWYgKHN0YXR1c0NvZGUgPiAyOTkpIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IG1zZztcbiAgICAgICAgICAgICAgICAgICAgLy8gaWYgZXhjZXB0aW9uL2Vycm9yIGluIGJvZHksIGF0dGVtcHQgdG8gZ2V0IGJldHRlciBlcnJvclxuICAgICAgICAgICAgICAgICAgICBpZiAob2JqICYmIG9iai5tZXNzYWdlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtc2cgPSBvYmoubWVzc2FnZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChjb250ZW50cyAmJiBjb250ZW50cy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBpdCBtYXkgYmUgdGhlIGNhc2UgdGhhdCB0aGUgZXhjZXB0aW9uIGlzIGluIHRoZSBib2R5IG1lc3NhZ2UgYXMgc3RyaW5nXG4gICAgICAgICAgICAgICAgICAgICAgICBtc2cgPSBjb250ZW50cztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1zZyA9IFwiRmFpbGVkIHJlcXVlc3Q6IChcIiArIHN0YXR1c0NvZGUgKyBcIilcIjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBsZXQgZXJyID0gbmV3IEVycm9yKG1zZyk7XG4gICAgICAgICAgICAgICAgICAgIC8vIGF0dGFjaCBzdGF0dXNDb2RlIGFuZCBib2R5IG9iaiAoaWYgYXZhaWxhYmxlKSB0byB0aGUgZXJyb3Igb2JqZWN0XG4gICAgICAgICAgICAgICAgICAgIGVyclsnc3RhdHVzQ29kZSddID0gc3RhdHVzQ29kZTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJlc3BvbnNlLnJlc3VsdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZXJyWydyZXN1bHQnXSA9IHJlc3BvbnNlLnJlc3VsdDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAocmVzcG9uc2UuaGVhZGVycykge1xuICAgICAgICAgICAgICAgICAgICAgICAgZXJyWydyZXNwb25zZUhlYWRlcnMnXSA9IHJlc3BvbnNlLmhlYWRlcnM7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmVqZWN0KGVycik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXNvbHZlKHJlc3BvbnNlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KSk7XG4gICAgICAgIH0pO1xuICAgIH1cbn1cbmV4cG9ydHMuUmVzdENsaWVudCA9IFJlc3RDbGllbnQ7XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/typed-rest-client/RestClient.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/typed-rest-client/Util.js":
/*!************************************************!*\
  !*** ./node_modules/typed-rest-client/Util.js ***!
  \************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\n// Copyright (c) Microsoft. All rights reserved.\n// Licensed under the MIT license. See LICENSE file in the project root for full license information.\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.getUrl = getUrl;\nexports.decompressGzippedContent = decompressGzippedContent;\nexports.buildProxyBypassRegexFromEnv = buildProxyBypassRegexFromEnv;\nexports.obtainContentCharset = obtainContentCharset;\nconst qs = __webpack_require__(/*! qs */ \"(rsc)/./node_modules/qs/lib/index.js\");\nconst url = __webpack_require__(/*! url */ \"url\");\nconst path = __webpack_require__(/*! path */ \"path\");\nconst zlib = __webpack_require__(/*! zlib */ \"zlib\");\n/**\n * creates an url from a request url and optional base url (http://server:8080)\n * @param {string} resource - a fully qualified url or relative path\n * @param {string} baseUrl - an optional baseUrl (http://server:8080)\n * @param {IRequestOptions} options - an optional options object, could include QueryParameters e.g.\n * @return {string} - resultant url\n */\nfunction getUrl(resource, baseUrl, queryParams) {\n    const pathApi = path.posix || path;\n    let requestUrl = '';\n    if (!baseUrl) {\n        requestUrl = resource;\n    }\n    else if (!resource) {\n        requestUrl = baseUrl;\n    }\n    else {\n        const base = url.parse(baseUrl);\n        const resultantUrl = url.parse(resource);\n        // resource (specific per request) elements take priority\n        resultantUrl.protocol = resultantUrl.protocol || base.protocol;\n        resultantUrl.auth = resultantUrl.auth || base.auth;\n        resultantUrl.host = resultantUrl.host || base.host;\n        resultantUrl.pathname = pathApi.resolve(base.pathname, resultantUrl.pathname);\n        if (!resultantUrl.pathname.endsWith('/') && resource.endsWith('/')) {\n            resultantUrl.pathname += '/';\n        }\n        requestUrl = url.format(resultantUrl);\n    }\n    return queryParams ?\n        getUrlWithParsedQueryParams(requestUrl, queryParams) :\n        requestUrl;\n}\n/**\n *\n * @param {string} requestUrl\n * @param {IRequestQueryParams} queryParams\n * @return {string} - Request's URL with Query Parameters appended/parsed.\n */\nfunction getUrlWithParsedQueryParams(requestUrl, queryParams) {\n    const url = requestUrl.replace(/\\?$/g, ''); // Clean any extra end-of-string \"?\" character\n    const parsedQueryParams = qs.stringify(queryParams.params, buildParamsStringifyOptions(queryParams));\n    return `${url}${parsedQueryParams}`;\n}\n/**\n * Build options for QueryParams Stringifying.\n *\n * @param {IRequestQueryParams} queryParams\n * @return {object}\n */\nfunction buildParamsStringifyOptions(queryParams) {\n    let options = {\n        addQueryPrefix: true,\n        delimiter: (queryParams.options || {}).separator || '&',\n        allowDots: (queryParams.options || {}).shouldAllowDots || false,\n        arrayFormat: (queryParams.options || {}).arrayFormat || 'repeat',\n        encodeValuesOnly: (queryParams.options || {}).shouldOnlyEncodeValues || true\n    };\n    return options;\n}\n/**\n * Decompress/Decode gzip encoded JSON\n * Using Node.js built-in zlib module\n *\n * @param {Buffer} buffer\n * @param {string} charset? - optional; defaults to 'utf-8'\n * @return {Promise<string>}\n */\nfunction decompressGzippedContent(buffer, charset) {\n    return __awaiter(this, void 0, void 0, function* () {\n        return new Promise((resolve, reject) => __awaiter(this, void 0, void 0, function* () {\n            zlib.gunzip(buffer, function (error, buffer) {\n                if (error) {\n                    reject(error);\n                }\n                else {\n                    resolve(buffer.toString(charset || 'utf-8'));\n                }\n            });\n        }));\n    });\n}\n/**\n * Builds a RegExp to test urls against for deciding\n * wether to bypass proxy from an entry of the\n * environment variable setting NO_PROXY\n *\n * @param {string} bypass\n * @return {RegExp}\n */\nfunction buildProxyBypassRegexFromEnv(bypass) {\n    try {\n        // We need to keep this around for back-compat purposes\n        return new RegExp(bypass, 'i');\n    }\n    catch (err) {\n        if (err instanceof SyntaxError && (bypass || \"\").startsWith(\"*\")) {\n            let wildcardEscaped = bypass.replace('*', '(.*)');\n            return new RegExp(wildcardEscaped, 'i');\n        }\n        throw err;\n    }\n}\n/**\n * Obtain Response's Content Charset.\n * Through inspecting `content-type` response header.\n * It Returns 'utf-8' if NO charset specified/matched.\n *\n * @param {IHttpClientResponse} response\n * @return {string} - Content Encoding Charset; Default=utf-8\n */\nfunction obtainContentCharset(response) {\n    // Find the charset, if specified.\n    // Search for the `charset=CHARSET` string, not including `;,\\r\\n`\n    // Example: content-type: 'application/json;charset=utf-8'\n    // |__ matches would be ['charset=utf-8', 'utf-8', index: 18, input: 'application/json; charset=utf-8']\n    // |_____ matches[1] would have the charset :tada: , in our example it's utf-8\n    // However, if the matches Array was empty or no charset found, 'utf-8' would be returned by default.\n    const nodeSupportedEncodings = ['ascii', 'utf8', 'utf16le', 'ucs2', 'base64', 'binary', 'hex'];\n    const contentType = response.message.headers['content-type'] || '';\n    const matches = contentType.match(/charset=([^;,\\r\\n]+)/i);\n    if (matches && matches[1] && nodeSupportedEncodings.indexOf(matches[1]) != -1) {\n        return matches[1];\n    }\n    return 'utf-8';\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvdHlwZWQtcmVzdC1jbGllbnQvVXRpbC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QiwrREFBK0QsaUJBQWlCO0FBQzVHO0FBQ0Esb0NBQW9DLE1BQU0sK0JBQStCLFlBQVk7QUFDckYsbUNBQW1DLE1BQU0sbUNBQW1DLFlBQVk7QUFDeEYsZ0NBQWdDO0FBQ2hDO0FBQ0EsS0FBSztBQUNMO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELGNBQWM7QUFDZCxnQ0FBZ0M7QUFDaEMsb0NBQW9DO0FBQ3BDLDRCQUE0QjtBQUM1QixXQUFXLG1CQUFPLENBQUMsZ0RBQUk7QUFDdkIsWUFBWSxtQkFBTyxDQUFDLGdCQUFLO0FBQ3pCLGFBQWEsbUJBQU8sQ0FBQyxrQkFBTTtBQUMzQixhQUFhLG1CQUFPLENBQUMsa0JBQU07QUFDM0I7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxpQkFBaUI7QUFDNUIsWUFBWSxRQUFRO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxxQkFBcUI7QUFDaEMsWUFBWSxRQUFRO0FBQ3BCO0FBQ0E7QUFDQSxnREFBZ0Q7QUFDaEQ7QUFDQSxjQUFjLElBQUksRUFBRSxrQkFBa0I7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLHFCQUFxQjtBQUNoQyxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkM7QUFDN0MsNkNBQTZDO0FBQzdDLCtDQUErQztBQUMvQyxvREFBb0Q7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRLHFCQUFxQjtBQUN4QyxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1QsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLHFCQUFxQjtBQUNoQyxZQUFZLFFBQVEsNEJBQTRCO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBLGdFQUFnRTtBQUNoRSxnREFBZ0Q7QUFDaEQsNEZBQTRGO0FBQzVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbURBQW1EO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIkM6XFxQcm9qZWN0c1xcQnVpbGRMYXVuY2hlclRlc3RcXG5vZGVfbW9kdWxlc1xcdHlwZWQtcmVzdC1jbGllbnRcXFV0aWwuanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG4vLyBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdC4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZS4gU2VlIExJQ0VOU0UgZmlsZSBpbiB0aGUgcHJvamVjdCByb290IGZvciBmdWxsIGxpY2Vuc2UgaW5mb3JtYXRpb24uXG52YXIgX19hd2FpdGVyID0gKHRoaXMgJiYgdGhpcy5fX2F3YWl0ZXIpIHx8IGZ1bmN0aW9uICh0aGlzQXJnLCBfYXJndW1lbnRzLCBQLCBnZW5lcmF0b3IpIHtcbiAgICBmdW5jdGlvbiBhZG9wdCh2YWx1ZSkgeyByZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBQID8gdmFsdWUgOiBuZXcgUChmdW5jdGlvbiAocmVzb2x2ZSkgeyByZXNvbHZlKHZhbHVlKTsgfSk7IH1cbiAgICByZXR1cm4gbmV3IChQIHx8IChQID0gUHJvbWlzZSkpKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgZnVuY3Rpb24gZnVsZmlsbGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yLm5leHQodmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxuICAgICAgICBmdW5jdGlvbiByZWplY3RlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvcltcInRocm93XCJdKHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cbiAgICAgICAgZnVuY3Rpb24gc3RlcChyZXN1bHQpIHsgcmVzdWx0LmRvbmUgPyByZXNvbHZlKHJlc3VsdC52YWx1ZSkgOiBhZG9wdChyZXN1bHQudmFsdWUpLnRoZW4oZnVsZmlsbGVkLCByZWplY3RlZCk7IH1cbiAgICAgICAgc3RlcCgoZ2VuZXJhdG9yID0gZ2VuZXJhdG9yLmFwcGx5KHRoaXNBcmcsIF9hcmd1bWVudHMgfHwgW10pKS5uZXh0KCkpO1xuICAgIH0pO1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuZ2V0VXJsID0gZ2V0VXJsO1xuZXhwb3J0cy5kZWNvbXByZXNzR3ppcHBlZENvbnRlbnQgPSBkZWNvbXByZXNzR3ppcHBlZENvbnRlbnQ7XG5leHBvcnRzLmJ1aWxkUHJveHlCeXBhc3NSZWdleEZyb21FbnYgPSBidWlsZFByb3h5QnlwYXNzUmVnZXhGcm9tRW52O1xuZXhwb3J0cy5vYnRhaW5Db250ZW50Q2hhcnNldCA9IG9idGFpbkNvbnRlbnRDaGFyc2V0O1xuY29uc3QgcXMgPSByZXF1aXJlKFwicXNcIik7XG5jb25zdCB1cmwgPSByZXF1aXJlKFwidXJsXCIpO1xuY29uc3QgcGF0aCA9IHJlcXVpcmUoXCJwYXRoXCIpO1xuY29uc3QgemxpYiA9IHJlcXVpcmUoXCJ6bGliXCIpO1xuLyoqXG4gKiBjcmVhdGVzIGFuIHVybCBmcm9tIGEgcmVxdWVzdCB1cmwgYW5kIG9wdGlvbmFsIGJhc2UgdXJsIChodHRwOi8vc2VydmVyOjgwODApXG4gKiBAcGFyYW0ge3N0cmluZ30gcmVzb3VyY2UgLSBhIGZ1bGx5IHF1YWxpZmllZCB1cmwgb3IgcmVsYXRpdmUgcGF0aFxuICogQHBhcmFtIHtzdHJpbmd9IGJhc2VVcmwgLSBhbiBvcHRpb25hbCBiYXNlVXJsIChodHRwOi8vc2VydmVyOjgwODApXG4gKiBAcGFyYW0ge0lSZXF1ZXN0T3B0aW9uc30gb3B0aW9ucyAtIGFuIG9wdGlvbmFsIG9wdGlvbnMgb2JqZWN0LCBjb3VsZCBpbmNsdWRlIFF1ZXJ5UGFyYW1ldGVycyBlLmcuXG4gKiBAcmV0dXJuIHtzdHJpbmd9IC0gcmVzdWx0YW50IHVybFxuICovXG5mdW5jdGlvbiBnZXRVcmwocmVzb3VyY2UsIGJhc2VVcmwsIHF1ZXJ5UGFyYW1zKSB7XG4gICAgY29uc3QgcGF0aEFwaSA9IHBhdGgucG9zaXggfHwgcGF0aDtcbiAgICBsZXQgcmVxdWVzdFVybCA9ICcnO1xuICAgIGlmICghYmFzZVVybCkge1xuICAgICAgICByZXF1ZXN0VXJsID0gcmVzb3VyY2U7XG4gICAgfVxuICAgIGVsc2UgaWYgKCFyZXNvdXJjZSkge1xuICAgICAgICByZXF1ZXN0VXJsID0gYmFzZVVybDtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGNvbnN0IGJhc2UgPSB1cmwucGFyc2UoYmFzZVVybCk7XG4gICAgICAgIGNvbnN0IHJlc3VsdGFudFVybCA9IHVybC5wYXJzZShyZXNvdXJjZSk7XG4gICAgICAgIC8vIHJlc291cmNlIChzcGVjaWZpYyBwZXIgcmVxdWVzdCkgZWxlbWVudHMgdGFrZSBwcmlvcml0eVxuICAgICAgICByZXN1bHRhbnRVcmwucHJvdG9jb2wgPSByZXN1bHRhbnRVcmwucHJvdG9jb2wgfHwgYmFzZS5wcm90b2NvbDtcbiAgICAgICAgcmVzdWx0YW50VXJsLmF1dGggPSByZXN1bHRhbnRVcmwuYXV0aCB8fCBiYXNlLmF1dGg7XG4gICAgICAgIHJlc3VsdGFudFVybC5ob3N0ID0gcmVzdWx0YW50VXJsLmhvc3QgfHwgYmFzZS5ob3N0O1xuICAgICAgICByZXN1bHRhbnRVcmwucGF0aG5hbWUgPSBwYXRoQXBpLnJlc29sdmUoYmFzZS5wYXRobmFtZSwgcmVzdWx0YW50VXJsLnBhdGhuYW1lKTtcbiAgICAgICAgaWYgKCFyZXN1bHRhbnRVcmwucGF0aG5hbWUuZW5kc1dpdGgoJy8nKSAmJiByZXNvdXJjZS5lbmRzV2l0aCgnLycpKSB7XG4gICAgICAgICAgICByZXN1bHRhbnRVcmwucGF0aG5hbWUgKz0gJy8nO1xuICAgICAgICB9XG4gICAgICAgIHJlcXVlc3RVcmwgPSB1cmwuZm9ybWF0KHJlc3VsdGFudFVybCk7XG4gICAgfVxuICAgIHJldHVybiBxdWVyeVBhcmFtcyA/XG4gICAgICAgIGdldFVybFdpdGhQYXJzZWRRdWVyeVBhcmFtcyhyZXF1ZXN0VXJsLCBxdWVyeVBhcmFtcykgOlxuICAgICAgICByZXF1ZXN0VXJsO1xufVxuLyoqXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHJlcXVlc3RVcmxcbiAqIEBwYXJhbSB7SVJlcXVlc3RRdWVyeVBhcmFtc30gcXVlcnlQYXJhbXNcbiAqIEByZXR1cm4ge3N0cmluZ30gLSBSZXF1ZXN0J3MgVVJMIHdpdGggUXVlcnkgUGFyYW1ldGVycyBhcHBlbmRlZC9wYXJzZWQuXG4gKi9cbmZ1bmN0aW9uIGdldFVybFdpdGhQYXJzZWRRdWVyeVBhcmFtcyhyZXF1ZXN0VXJsLCBxdWVyeVBhcmFtcykge1xuICAgIGNvbnN0IHVybCA9IHJlcXVlc3RVcmwucmVwbGFjZSgvXFw/JC9nLCAnJyk7IC8vIENsZWFuIGFueSBleHRyYSBlbmQtb2Ytc3RyaW5nIFwiP1wiIGNoYXJhY3RlclxuICAgIGNvbnN0IHBhcnNlZFF1ZXJ5UGFyYW1zID0gcXMuc3RyaW5naWZ5KHF1ZXJ5UGFyYW1zLnBhcmFtcywgYnVpbGRQYXJhbXNTdHJpbmdpZnlPcHRpb25zKHF1ZXJ5UGFyYW1zKSk7XG4gICAgcmV0dXJuIGAke3VybH0ke3BhcnNlZFF1ZXJ5UGFyYW1zfWA7XG59XG4vKipcbiAqIEJ1aWxkIG9wdGlvbnMgZm9yIFF1ZXJ5UGFyYW1zIFN0cmluZ2lmeWluZy5cbiAqXG4gKiBAcGFyYW0ge0lSZXF1ZXN0UXVlcnlQYXJhbXN9IHF1ZXJ5UGFyYW1zXG4gKiBAcmV0dXJuIHtvYmplY3R9XG4gKi9cbmZ1bmN0aW9uIGJ1aWxkUGFyYW1zU3RyaW5naWZ5T3B0aW9ucyhxdWVyeVBhcmFtcykge1xuICAgIGxldCBvcHRpb25zID0ge1xuICAgICAgICBhZGRRdWVyeVByZWZpeDogdHJ1ZSxcbiAgICAgICAgZGVsaW1pdGVyOiAocXVlcnlQYXJhbXMub3B0aW9ucyB8fCB7fSkuc2VwYXJhdG9yIHx8ICcmJyxcbiAgICAgICAgYWxsb3dEb3RzOiAocXVlcnlQYXJhbXMub3B0aW9ucyB8fCB7fSkuc2hvdWxkQWxsb3dEb3RzIHx8IGZhbHNlLFxuICAgICAgICBhcnJheUZvcm1hdDogKHF1ZXJ5UGFyYW1zLm9wdGlvbnMgfHwge30pLmFycmF5Rm9ybWF0IHx8ICdyZXBlYXQnLFxuICAgICAgICBlbmNvZGVWYWx1ZXNPbmx5OiAocXVlcnlQYXJhbXMub3B0aW9ucyB8fCB7fSkuc2hvdWxkT25seUVuY29kZVZhbHVlcyB8fCB0cnVlXG4gICAgfTtcbiAgICByZXR1cm4gb3B0aW9ucztcbn1cbi8qKlxuICogRGVjb21wcmVzcy9EZWNvZGUgZ3ppcCBlbmNvZGVkIEpTT05cbiAqIFVzaW5nIE5vZGUuanMgYnVpbHQtaW4gemxpYiBtb2R1bGVcbiAqXG4gKiBAcGFyYW0ge0J1ZmZlcn0gYnVmZmVyXG4gKiBAcGFyYW0ge3N0cmluZ30gY2hhcnNldD8gLSBvcHRpb25hbDsgZGVmYXVsdHMgdG8gJ3V0Zi04J1xuICogQHJldHVybiB7UHJvbWlzZTxzdHJpbmc+fVxuICovXG5mdW5jdGlvbiBkZWNvbXByZXNzR3ppcHBlZENvbnRlbnQoYnVmZmVyLCBjaGFyc2V0KSB7XG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIHpsaWIuZ3VuemlwKGJ1ZmZlciwgZnVuY3Rpb24gKGVycm9yLCBidWZmZXIpIHtcbiAgICAgICAgICAgICAgICBpZiAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVqZWN0KGVycm9yKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc29sdmUoYnVmZmVyLnRvU3RyaW5nKGNoYXJzZXQgfHwgJ3V0Zi04JykpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KSk7XG4gICAgfSk7XG59XG4vKipcbiAqIEJ1aWxkcyBhIFJlZ0V4cCB0byB0ZXN0IHVybHMgYWdhaW5zdCBmb3IgZGVjaWRpbmdcbiAqIHdldGhlciB0byBieXBhc3MgcHJveHkgZnJvbSBhbiBlbnRyeSBvZiB0aGVcbiAqIGVudmlyb25tZW50IHZhcmlhYmxlIHNldHRpbmcgTk9fUFJPWFlcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gYnlwYXNzXG4gKiBAcmV0dXJuIHtSZWdFeHB9XG4gKi9cbmZ1bmN0aW9uIGJ1aWxkUHJveHlCeXBhc3NSZWdleEZyb21FbnYoYnlwYXNzKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgLy8gV2UgbmVlZCB0byBrZWVwIHRoaXMgYXJvdW5kIGZvciBiYWNrLWNvbXBhdCBwdXJwb3Nlc1xuICAgICAgICByZXR1cm4gbmV3IFJlZ0V4cChieXBhc3MsICdpJyk7XG4gICAgfVxuICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgaWYgKGVyciBpbnN0YW5jZW9mIFN5bnRheEVycm9yICYmIChieXBhc3MgfHwgXCJcIikuc3RhcnRzV2l0aChcIipcIikpIHtcbiAgICAgICAgICAgIGxldCB3aWxkY2FyZEVzY2FwZWQgPSBieXBhc3MucmVwbGFjZSgnKicsICcoLiopJyk7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFJlZ0V4cCh3aWxkY2FyZEVzY2FwZWQsICdpJyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgZXJyO1xuICAgIH1cbn1cbi8qKlxuICogT2J0YWluIFJlc3BvbnNlJ3MgQ29udGVudCBDaGFyc2V0LlxuICogVGhyb3VnaCBpbnNwZWN0aW5nIGBjb250ZW50LXR5cGVgIHJlc3BvbnNlIGhlYWRlci5cbiAqIEl0IFJldHVybnMgJ3V0Zi04JyBpZiBOTyBjaGFyc2V0IHNwZWNpZmllZC9tYXRjaGVkLlxuICpcbiAqIEBwYXJhbSB7SUh0dHBDbGllbnRSZXNwb25zZX0gcmVzcG9uc2VcbiAqIEByZXR1cm4ge3N0cmluZ30gLSBDb250ZW50IEVuY29kaW5nIENoYXJzZXQ7IERlZmF1bHQ9dXRmLThcbiAqL1xuZnVuY3Rpb24gb2J0YWluQ29udGVudENoYXJzZXQocmVzcG9uc2UpIHtcbiAgICAvLyBGaW5kIHRoZSBjaGFyc2V0LCBpZiBzcGVjaWZpZWQuXG4gICAgLy8gU2VhcmNoIGZvciB0aGUgYGNoYXJzZXQ9Q0hBUlNFVGAgc3RyaW5nLCBub3QgaW5jbHVkaW5nIGA7LFxcclxcbmBcbiAgICAvLyBFeGFtcGxlOiBjb250ZW50LXR5cGU6ICdhcHBsaWNhdGlvbi9qc29uO2NoYXJzZXQ9dXRmLTgnXG4gICAgLy8gfF9fIG1hdGNoZXMgd291bGQgYmUgWydjaGFyc2V0PXV0Zi04JywgJ3V0Zi04JywgaW5kZXg6IDE4LCBpbnB1dDogJ2FwcGxpY2F0aW9uL2pzb247IGNoYXJzZXQ9dXRmLTgnXVxuICAgIC8vIHxfX19fXyBtYXRjaGVzWzFdIHdvdWxkIGhhdmUgdGhlIGNoYXJzZXQgOnRhZGE6ICwgaW4gb3VyIGV4YW1wbGUgaXQncyB1dGYtOFxuICAgIC8vIEhvd2V2ZXIsIGlmIHRoZSBtYXRjaGVzIEFycmF5IHdhcyBlbXB0eSBvciBubyBjaGFyc2V0IGZvdW5kLCAndXRmLTgnIHdvdWxkIGJlIHJldHVybmVkIGJ5IGRlZmF1bHQuXG4gICAgY29uc3Qgbm9kZVN1cHBvcnRlZEVuY29kaW5ncyA9IFsnYXNjaWknLCAndXRmOCcsICd1dGYxNmxlJywgJ3VjczInLCAnYmFzZTY0JywgJ2JpbmFyeScsICdoZXgnXTtcbiAgICBjb25zdCBjb250ZW50VHlwZSA9IHJlc3BvbnNlLm1lc3NhZ2UuaGVhZGVyc1snY29udGVudC10eXBlJ10gfHwgJyc7XG4gICAgY29uc3QgbWF0Y2hlcyA9IGNvbnRlbnRUeXBlLm1hdGNoKC9jaGFyc2V0PShbXjssXFxyXFxuXSspL2kpO1xuICAgIGlmIChtYXRjaGVzICYmIG1hdGNoZXNbMV0gJiYgbm9kZVN1cHBvcnRlZEVuY29kaW5ncy5pbmRleE9mKG1hdGNoZXNbMV0pICE9IC0xKSB7XG4gICAgICAgIHJldHVybiBtYXRjaGVzWzFdO1xuICAgIH1cbiAgICByZXR1cm4gJ3V0Zi04Jztcbn1cbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/typed-rest-client/Util.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/typed-rest-client/handlers/basiccreds.js":
/*!***************************************************************!*\
  !*** ./node_modules/typed-rest-client/handlers/basiccreds.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\n// Copyright (c) Microsoft. All rights reserved.\n// Licensed under the MIT license. See LICENSE file in the project root for full license information.\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.BasicCredentialHandler = void 0;\nclass BasicCredentialHandler {\n    constructor(username, password, allowCrossOriginAuthentication) {\n        this.username = username;\n        this.password = password;\n        this.allowCrossOriginAuthentication = allowCrossOriginAuthentication;\n    }\n    // currently implements pre-authorization\n    // TODO: support preAuth = false where it hooks on 401\n    prepareRequest(options) {\n        if (!this.origin) {\n            this.origin = options.host;\n        }\n        // If this is a redirection, don't set the Authorization header\n        if (this.origin === options.host || this.allowCrossOriginAuthentication) {\n            options.headers['Authorization'] = `Basic ${Buffer.from(`${this.username}:${this.password}`).toString('base64')}`;\n        }\n        options.headers['X-TFS-FedAuthRedirect'] = 'Suppress';\n    }\n    // This handler cannot handle 401\n    canHandleAuthentication(response) {\n        return false;\n    }\n    handleAuthentication(httpClient, requestInfo, objs) {\n        return null;\n    }\n}\nexports.BasicCredentialHandler = BasicCredentialHandler;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvdHlwZWQtcmVzdC1jbGllbnQvaGFuZGxlcnMvYmFzaWNjcmVkcy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3REFBd0QsZUFBZSxjQUFjLEdBQUcsY0FBYyxzQkFBc0I7QUFDNUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QiIsInNvdXJjZXMiOlsiQzpcXFByb2plY3RzXFxCdWlsZExhdW5jaGVyVGVzdFxcbm9kZV9tb2R1bGVzXFx0eXBlZC1yZXN0LWNsaWVudFxcaGFuZGxlcnNcXGJhc2ljY3JlZHMuanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG4vLyBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdC4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZS4gU2VlIExJQ0VOU0UgZmlsZSBpbiB0aGUgcHJvamVjdCByb290IGZvciBmdWxsIGxpY2Vuc2UgaW5mb3JtYXRpb24uXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkJhc2ljQ3JlZGVudGlhbEhhbmRsZXIgPSB2b2lkIDA7XG5jbGFzcyBCYXNpY0NyZWRlbnRpYWxIYW5kbGVyIHtcbiAgICBjb25zdHJ1Y3Rvcih1c2VybmFtZSwgcGFzc3dvcmQsIGFsbG93Q3Jvc3NPcmlnaW5BdXRoZW50aWNhdGlvbikge1xuICAgICAgICB0aGlzLnVzZXJuYW1lID0gdXNlcm5hbWU7XG4gICAgICAgIHRoaXMucGFzc3dvcmQgPSBwYXNzd29yZDtcbiAgICAgICAgdGhpcy5hbGxvd0Nyb3NzT3JpZ2luQXV0aGVudGljYXRpb24gPSBhbGxvd0Nyb3NzT3JpZ2luQXV0aGVudGljYXRpb247XG4gICAgfVxuICAgIC8vIGN1cnJlbnRseSBpbXBsZW1lbnRzIHByZS1hdXRob3JpemF0aW9uXG4gICAgLy8gVE9ETzogc3VwcG9ydCBwcmVBdXRoID0gZmFsc2Ugd2hlcmUgaXQgaG9va3Mgb24gNDAxXG4gICAgcHJlcGFyZVJlcXVlc3Qob3B0aW9ucykge1xuICAgICAgICBpZiAoIXRoaXMub3JpZ2luKSB7XG4gICAgICAgICAgICB0aGlzLm9yaWdpbiA9IG9wdGlvbnMuaG9zdDtcbiAgICAgICAgfVxuICAgICAgICAvLyBJZiB0aGlzIGlzIGEgcmVkaXJlY3Rpb24sIGRvbid0IHNldCB0aGUgQXV0aG9yaXphdGlvbiBoZWFkZXJcbiAgICAgICAgaWYgKHRoaXMub3JpZ2luID09PSBvcHRpb25zLmhvc3QgfHwgdGhpcy5hbGxvd0Nyb3NzT3JpZ2luQXV0aGVudGljYXRpb24pIHtcbiAgICAgICAgICAgIG9wdGlvbnMuaGVhZGVyc1snQXV0aG9yaXphdGlvbiddID0gYEJhc2ljICR7QnVmZmVyLmZyb20oYCR7dGhpcy51c2VybmFtZX06JHt0aGlzLnBhc3N3b3JkfWApLnRvU3RyaW5nKCdiYXNlNjQnKX1gO1xuICAgICAgICB9XG4gICAgICAgIG9wdGlvbnMuaGVhZGVyc1snWC1URlMtRmVkQXV0aFJlZGlyZWN0J10gPSAnU3VwcHJlc3MnO1xuICAgIH1cbiAgICAvLyBUaGlzIGhhbmRsZXIgY2Fubm90IGhhbmRsZSA0MDFcbiAgICBjYW5IYW5kbGVBdXRoZW50aWNhdGlvbihyZXNwb25zZSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGhhbmRsZUF1dGhlbnRpY2F0aW9uKGh0dHBDbGllbnQsIHJlcXVlc3RJbmZvLCBvYmpzKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbn1cbmV4cG9ydHMuQmFzaWNDcmVkZW50aWFsSGFuZGxlciA9IEJhc2ljQ3JlZGVudGlhbEhhbmRsZXI7XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/typed-rest-client/handlers/basiccreds.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/typed-rest-client/handlers/bearertoken.js":
/*!****************************************************************!*\
  !*** ./node_modules/typed-rest-client/handlers/bearertoken.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\n// Copyright (c) Microsoft. All rights reserved.\n// Licensed under the MIT license. See LICENSE file in the project root for full license information.\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.BearerCredentialHandler = void 0;\nclass BearerCredentialHandler {\n    constructor(token, allowCrossOriginAuthentication) {\n        this.token = token;\n        this.allowCrossOriginAuthentication = allowCrossOriginAuthentication;\n    }\n    // currently implements pre-authorization\n    // TODO: support preAuth = false where it hooks on 401\n    prepareRequest(options) {\n        if (!this.origin) {\n            this.origin = options.host;\n        }\n        // If this is a redirection, don't set the Authorization header\n        if (this.origin === options.host || this.allowCrossOriginAuthentication) {\n            options.headers['Authorization'] = `Bearer ${this.token}`;\n        }\n        options.headers['X-TFS-FedAuthRedirect'] = 'Suppress';\n    }\n    // This handler cannot handle 401\n    canHandleAuthentication(response) {\n        return false;\n    }\n    handleAuthentication(httpClient, requestInfo, objs) {\n        return null;\n    }\n}\nexports.BearerCredentialHandler = BearerCredentialHandler;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvdHlwZWQtcmVzdC1jbGllbnQvaGFuZGxlcnMvYmVhcmVydG9rZW4uanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELCtCQUErQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlEQUF5RCxXQUFXO0FBQ3BFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IiLCJzb3VyY2VzIjpbIkM6XFxQcm9qZWN0c1xcQnVpbGRMYXVuY2hlclRlc3RcXG5vZGVfbW9kdWxlc1xcdHlwZWQtcmVzdC1jbGllbnRcXGhhbmRsZXJzXFxiZWFyZXJ0b2tlbi5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbi8vIENvcHlyaWdodCAoYykgTWljcm9zb2Z0LiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuLy8gTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlLiBTZWUgTElDRU5TRSBmaWxlIGluIHRoZSBwcm9qZWN0IHJvb3QgZm9yIGZ1bGwgbGljZW5zZSBpbmZvcm1hdGlvbi5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuQmVhcmVyQ3JlZGVudGlhbEhhbmRsZXIgPSB2b2lkIDA7XG5jbGFzcyBCZWFyZXJDcmVkZW50aWFsSGFuZGxlciB7XG4gICAgY29uc3RydWN0b3IodG9rZW4sIGFsbG93Q3Jvc3NPcmlnaW5BdXRoZW50aWNhdGlvbikge1xuICAgICAgICB0aGlzLnRva2VuID0gdG9rZW47XG4gICAgICAgIHRoaXMuYWxsb3dDcm9zc09yaWdpbkF1dGhlbnRpY2F0aW9uID0gYWxsb3dDcm9zc09yaWdpbkF1dGhlbnRpY2F0aW9uO1xuICAgIH1cbiAgICAvLyBjdXJyZW50bHkgaW1wbGVtZW50cyBwcmUtYXV0aG9yaXphdGlvblxuICAgIC8vIFRPRE86IHN1cHBvcnQgcHJlQXV0aCA9IGZhbHNlIHdoZXJlIGl0IGhvb2tzIG9uIDQwMVxuICAgIHByZXBhcmVSZXF1ZXN0KG9wdGlvbnMpIHtcbiAgICAgICAgaWYgKCF0aGlzLm9yaWdpbikge1xuICAgICAgICAgICAgdGhpcy5vcmlnaW4gPSBvcHRpb25zLmhvc3Q7XG4gICAgICAgIH1cbiAgICAgICAgLy8gSWYgdGhpcyBpcyBhIHJlZGlyZWN0aW9uLCBkb24ndCBzZXQgdGhlIEF1dGhvcml6YXRpb24gaGVhZGVyXG4gICAgICAgIGlmICh0aGlzLm9yaWdpbiA9PT0gb3B0aW9ucy5ob3N0IHx8IHRoaXMuYWxsb3dDcm9zc09yaWdpbkF1dGhlbnRpY2F0aW9uKSB7XG4gICAgICAgICAgICBvcHRpb25zLmhlYWRlcnNbJ0F1dGhvcml6YXRpb24nXSA9IGBCZWFyZXIgJHt0aGlzLnRva2VufWA7XG4gICAgICAgIH1cbiAgICAgICAgb3B0aW9ucy5oZWFkZXJzWydYLVRGUy1GZWRBdXRoUmVkaXJlY3QnXSA9ICdTdXBwcmVzcyc7XG4gICAgfVxuICAgIC8vIFRoaXMgaGFuZGxlciBjYW5ub3QgaGFuZGxlIDQwMVxuICAgIGNhbkhhbmRsZUF1dGhlbnRpY2F0aW9uKHJlc3BvbnNlKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaGFuZGxlQXV0aGVudGljYXRpb24oaHR0cENsaWVudCwgcmVxdWVzdEluZm8sIG9ianMpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxufVxuZXhwb3J0cy5CZWFyZXJDcmVkZW50aWFsSGFuZGxlciA9IEJlYXJlckNyZWRlbnRpYWxIYW5kbGVyO1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/typed-rest-client/handlers/bearertoken.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/typed-rest-client/handlers/ntlm.js":
/*!*********************************************************!*\
  !*** ./node_modules/typed-rest-client/handlers/ntlm.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n// Copyright (c) Microsoft. All rights reserved.\n// Licensed under the MIT license. See LICENSE file in the project root for full license information.\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.NtlmCredentialHandler = void 0;\nconst http = __webpack_require__(/*! http */ \"http\");\nconst https = __webpack_require__(/*! https */ \"https\");\nconst _ = __webpack_require__(/*! underscore */ \"(rsc)/./node_modules/underscore/modules/index-all.js\");\nconst ntlm = __webpack_require__(/*! ../opensource/Node-SMB/lib/ntlm */ \"(rsc)/./node_modules/typed-rest-client/opensource/Node-SMB/lib/ntlm.js\");\nclass NtlmCredentialHandler {\n    constructor(username, password, workstation, domain) {\n        this._ntlmOptions = {};\n        this._ntlmOptions.username = username;\n        this._ntlmOptions.password = password;\n        this._ntlmOptions.domain = domain || '';\n        this._ntlmOptions.workstation = workstation || '';\n    }\n    prepareRequest(options) {\n        // No headers or options need to be set.  We keep the credentials on the handler itself.\n        // If a (proxy) agent is set, remove it as we don't support proxy for NTLM at this time\n        if (options.agent) {\n            delete options.agent;\n        }\n    }\n    canHandleAuthentication(response) {\n        if (response && response.message && response.message.statusCode === 401) {\n            // Ensure that we're talking NTLM here\n            // Once we have the www-authenticate header, split it so we can ensure we can talk NTLM\n            const wwwAuthenticate = response.message.headers['www-authenticate'];\n            return wwwAuthenticate && (wwwAuthenticate.split(', ').indexOf(\"NTLM\") >= 0);\n        }\n        return false;\n    }\n    handleAuthentication(httpClient, requestInfo, objs) {\n        return new Promise((resolve, reject) => {\n            const callbackForResult = function (err, res) {\n                if (err) {\n                    reject(err);\n                    return;\n                }\n                // We have to readbody on the response before continuing otherwise there is a hang.\n                res.readBody().then(() => {\n                    resolve(res);\n                });\n            };\n            this.handleAuthenticationPrivate(httpClient, requestInfo, objs, callbackForResult);\n        });\n    }\n    handleAuthenticationPrivate(httpClient, requestInfo, objs, finalCallback) {\n        // Set up the headers for NTLM authentication\n        requestInfo.options = _.extend(requestInfo.options, {\n            username: this._ntlmOptions.username,\n            password: this._ntlmOptions.password,\n            domain: this._ntlmOptions.domain,\n            workstation: this._ntlmOptions.workstation\n        });\n        requestInfo.options.agent = httpClient.isSsl ?\n            new https.Agent({ keepAlive: true }) :\n            new http.Agent({ keepAlive: true });\n        let self = this;\n        // The following pattern of sending the type1 message following immediately (in a setImmediate) is\n        // critical for the NTLM exchange to happen.  If we removed setImmediate (or call in a different manner)\n        // the NTLM exchange will always fail with a 401.\n        this.sendType1Message(httpClient, requestInfo, objs, function (err, res) {\n            if (err) {\n                return finalCallback(err, null, null);\n            }\n            /// We have to readbody on the response before continuing otherwise there is a hang.\n            res.readBody().then(() => {\n                // It is critical that we have setImmediate here due to how connection requests are queued.\n                // If setImmediate is removed then the NTLM handshake will not work.\n                // setImmediate allows us to queue a second request on the same connection. If this second\n                // request is not queued on the connection when the first request finishes then node closes\n                // the connection. NTLM requires both requests to be on the same connection so we need this.\n                setImmediate(function () {\n                    self.sendType3Message(httpClient, requestInfo, objs, res, finalCallback);\n                });\n            });\n        });\n    }\n    // The following method is an adaptation of code found at https://github.com/SamDecrock/node-http-ntlm/blob/master/httpntlm.js\n    sendType1Message(httpClient, requestInfo, objs, finalCallback) {\n        const type1HexBuffer = ntlm.encodeType1(this._ntlmOptions.workstation, this._ntlmOptions.domain);\n        const type1msg = `NTLM ${type1HexBuffer.toString('base64')}`;\n        const type1options = {\n            headers: {\n                'Connection': 'keep-alive',\n                'Authorization': type1msg\n            },\n            timeout: requestInfo.options.timeout || 0,\n            agent: requestInfo.httpModule,\n        };\n        const type1info = {};\n        type1info.httpModule = requestInfo.httpModule;\n        type1info.parsedUrl = requestInfo.parsedUrl;\n        type1info.options = _.extend(type1options, _.omit(requestInfo.options, 'headers'));\n        return httpClient.requestRawWithCallback(type1info, objs, finalCallback);\n    }\n    // The following method is an adaptation of code found at https://github.com/SamDecrock/node-http-ntlm/blob/master/httpntlm.js\n    sendType3Message(httpClient, requestInfo, objs, res, callback) {\n        if (!res.message.headers && !res.message.headers['www-authenticate']) {\n            throw new Error('www-authenticate not found on response of second request');\n        }\n        /**\n         * Server will respond with challenge/nonce\n         * assigned to response's \"WWW-AUTHENTICATE\" header\n         * and should adhere to RegExp /^NTLM\\s+(.+?)(,|\\s+|$)/\n         */\n        const serverNonceRegex = /^NTLM\\s+(.+?)(,|\\s+|$)/;\n        const serverNonce = Buffer.from((res.message.headers['www-authenticate'].match(serverNonceRegex) || [])[1], 'base64');\n        let type2msg;\n        /**\n         * Wrap decoding the Server's challenge/nonce in\n         * try-catch block to throw more comprehensive\n         * Error with clear message to consumer\n         */\n        try {\n            type2msg = ntlm.decodeType2(serverNonce);\n        }\n        catch (error) {\n            throw new Error(`Decoding Server's Challenge to Obtain Type2Message failed with error: ${error.message}`);\n        }\n        const type3msg = ntlm.encodeType3(this._ntlmOptions.username, this._ntlmOptions.workstation, this._ntlmOptions.domain, type2msg, this._ntlmOptions.password).toString('base64');\n        const type3options = {\n            headers: {\n                'Authorization': `NTLM ${type3msg}`,\n                'Connection': 'Close'\n            },\n            agent: requestInfo.httpModule,\n        };\n        const type3info = {};\n        type3info.httpModule = requestInfo.httpModule;\n        type3info.parsedUrl = requestInfo.parsedUrl;\n        type3options.headers = _.extend(type3options.headers, requestInfo.options.headers);\n        type3info.options = _.extend(type3options, _.omit(requestInfo.options, 'headers'));\n        return httpClient.requestRawWithCallback(type3info, objs, callback);\n    }\n}\nexports.NtlmCredentialHandler = NtlmCredentialHandler;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvdHlwZWQtcmVzdC1jbGllbnQvaGFuZGxlcnMvbnRsbS5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsNkJBQTZCO0FBQzdCLGFBQWEsbUJBQU8sQ0FBQyxrQkFBTTtBQUMzQixjQUFjLG1CQUFPLENBQUMsb0JBQU87QUFDN0IsVUFBVSxtQkFBTyxDQUFDLHdFQUFZO0FBQzlCLGFBQWEsbUJBQU8sQ0FBQywrR0FBaUM7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsOEJBQThCLGlCQUFpQjtBQUMvQyw2QkFBNkIsaUJBQWlCO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyxrQ0FBa0M7QUFDbkU7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxR0FBcUcsY0FBYztBQUNuSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QyxTQUFTO0FBQ2xEO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCIiwic291cmNlcyI6WyJDOlxcUHJvamVjdHNcXEJ1aWxkTGF1bmNoZXJUZXN0XFxub2RlX21vZHVsZXNcXHR5cGVkLXJlc3QtY2xpZW50XFxoYW5kbGVyc1xcbnRsbS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbi8vIENvcHlyaWdodCAoYykgTWljcm9zb2Z0LiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuLy8gTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlLiBTZWUgTElDRU5TRSBmaWxlIGluIHRoZSBwcm9qZWN0IHJvb3QgZm9yIGZ1bGwgbGljZW5zZSBpbmZvcm1hdGlvbi5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuTnRsbUNyZWRlbnRpYWxIYW5kbGVyID0gdm9pZCAwO1xuY29uc3QgaHR0cCA9IHJlcXVpcmUoXCJodHRwXCIpO1xuY29uc3QgaHR0cHMgPSByZXF1aXJlKFwiaHR0cHNcIik7XG5jb25zdCBfID0gcmVxdWlyZShcInVuZGVyc2NvcmVcIik7XG5jb25zdCBudGxtID0gcmVxdWlyZShcIi4uL29wZW5zb3VyY2UvTm9kZS1TTUIvbGliL250bG1cIik7XG5jbGFzcyBOdGxtQ3JlZGVudGlhbEhhbmRsZXIge1xuICAgIGNvbnN0cnVjdG9yKHVzZXJuYW1lLCBwYXNzd29yZCwgd29ya3N0YXRpb24sIGRvbWFpbikge1xuICAgICAgICB0aGlzLl9udGxtT3B0aW9ucyA9IHt9O1xuICAgICAgICB0aGlzLl9udGxtT3B0aW9ucy51c2VybmFtZSA9IHVzZXJuYW1lO1xuICAgICAgICB0aGlzLl9udGxtT3B0aW9ucy5wYXNzd29yZCA9IHBhc3N3b3JkO1xuICAgICAgICB0aGlzLl9udGxtT3B0aW9ucy5kb21haW4gPSBkb21haW4gfHwgJyc7XG4gICAgICAgIHRoaXMuX250bG1PcHRpb25zLndvcmtzdGF0aW9uID0gd29ya3N0YXRpb24gfHwgJyc7XG4gICAgfVxuICAgIHByZXBhcmVSZXF1ZXN0KG9wdGlvbnMpIHtcbiAgICAgICAgLy8gTm8gaGVhZGVycyBvciBvcHRpb25zIG5lZWQgdG8gYmUgc2V0LiAgV2Uga2VlcCB0aGUgY3JlZGVudGlhbHMgb24gdGhlIGhhbmRsZXIgaXRzZWxmLlxuICAgICAgICAvLyBJZiBhIChwcm94eSkgYWdlbnQgaXMgc2V0LCByZW1vdmUgaXQgYXMgd2UgZG9uJ3Qgc3VwcG9ydCBwcm94eSBmb3IgTlRMTSBhdCB0aGlzIHRpbWVcbiAgICAgICAgaWYgKG9wdGlvbnMuYWdlbnQpIHtcbiAgICAgICAgICAgIGRlbGV0ZSBvcHRpb25zLmFnZW50O1xuICAgICAgICB9XG4gICAgfVxuICAgIGNhbkhhbmRsZUF1dGhlbnRpY2F0aW9uKHJlc3BvbnNlKSB7XG4gICAgICAgIGlmIChyZXNwb25zZSAmJiByZXNwb25zZS5tZXNzYWdlICYmIHJlc3BvbnNlLm1lc3NhZ2Uuc3RhdHVzQ29kZSA9PT0gNDAxKSB7XG4gICAgICAgICAgICAvLyBFbnN1cmUgdGhhdCB3ZSdyZSB0YWxraW5nIE5UTE0gaGVyZVxuICAgICAgICAgICAgLy8gT25jZSB3ZSBoYXZlIHRoZSB3d3ctYXV0aGVudGljYXRlIGhlYWRlciwgc3BsaXQgaXQgc28gd2UgY2FuIGVuc3VyZSB3ZSBjYW4gdGFsayBOVExNXG4gICAgICAgICAgICBjb25zdCB3d3dBdXRoZW50aWNhdGUgPSByZXNwb25zZS5tZXNzYWdlLmhlYWRlcnNbJ3d3dy1hdXRoZW50aWNhdGUnXTtcbiAgICAgICAgICAgIHJldHVybiB3d3dBdXRoZW50aWNhdGUgJiYgKHd3d0F1dGhlbnRpY2F0ZS5zcGxpdCgnLCAnKS5pbmRleE9mKFwiTlRMTVwiKSA+PSAwKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGhhbmRsZUF1dGhlbnRpY2F0aW9uKGh0dHBDbGllbnQsIHJlcXVlc3RJbmZvLCBvYmpzKSB7XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICBjb25zdCBjYWxsYmFja0ZvclJlc3VsdCA9IGZ1bmN0aW9uIChlcnIsIHJlcykge1xuICAgICAgICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVqZWN0KGVycik7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gV2UgaGF2ZSB0byByZWFkYm9keSBvbiB0aGUgcmVzcG9uc2UgYmVmb3JlIGNvbnRpbnVpbmcgb3RoZXJ3aXNlIHRoZXJlIGlzIGEgaGFuZy5cbiAgICAgICAgICAgICAgICByZXMucmVhZEJvZHkoKS50aGVuKCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZShyZXMpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHRoaXMuaGFuZGxlQXV0aGVudGljYXRpb25Qcml2YXRlKGh0dHBDbGllbnQsIHJlcXVlc3RJbmZvLCBvYmpzLCBjYWxsYmFja0ZvclJlc3VsdCk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBoYW5kbGVBdXRoZW50aWNhdGlvblByaXZhdGUoaHR0cENsaWVudCwgcmVxdWVzdEluZm8sIG9ianMsIGZpbmFsQ2FsbGJhY2spIHtcbiAgICAgICAgLy8gU2V0IHVwIHRoZSBoZWFkZXJzIGZvciBOVExNIGF1dGhlbnRpY2F0aW9uXG4gICAgICAgIHJlcXVlc3RJbmZvLm9wdGlvbnMgPSBfLmV4dGVuZChyZXF1ZXN0SW5mby5vcHRpb25zLCB7XG4gICAgICAgICAgICB1c2VybmFtZTogdGhpcy5fbnRsbU9wdGlvbnMudXNlcm5hbWUsXG4gICAgICAgICAgICBwYXNzd29yZDogdGhpcy5fbnRsbU9wdGlvbnMucGFzc3dvcmQsXG4gICAgICAgICAgICBkb21haW46IHRoaXMuX250bG1PcHRpb25zLmRvbWFpbixcbiAgICAgICAgICAgIHdvcmtzdGF0aW9uOiB0aGlzLl9udGxtT3B0aW9ucy53b3Jrc3RhdGlvblxuICAgICAgICB9KTtcbiAgICAgICAgcmVxdWVzdEluZm8ub3B0aW9ucy5hZ2VudCA9IGh0dHBDbGllbnQuaXNTc2wgP1xuICAgICAgICAgICAgbmV3IGh0dHBzLkFnZW50KHsga2VlcEFsaXZlOiB0cnVlIH0pIDpcbiAgICAgICAgICAgIG5ldyBodHRwLkFnZW50KHsga2VlcEFsaXZlOiB0cnVlIH0pO1xuICAgICAgICBsZXQgc2VsZiA9IHRoaXM7XG4gICAgICAgIC8vIFRoZSBmb2xsb3dpbmcgcGF0dGVybiBvZiBzZW5kaW5nIHRoZSB0eXBlMSBtZXNzYWdlIGZvbGxvd2luZyBpbW1lZGlhdGVseSAoaW4gYSBzZXRJbW1lZGlhdGUpIGlzXG4gICAgICAgIC8vIGNyaXRpY2FsIGZvciB0aGUgTlRMTSBleGNoYW5nZSB0byBoYXBwZW4uICBJZiB3ZSByZW1vdmVkIHNldEltbWVkaWF0ZSAob3IgY2FsbCBpbiBhIGRpZmZlcmVudCBtYW5uZXIpXG4gICAgICAgIC8vIHRoZSBOVExNIGV4Y2hhbmdlIHdpbGwgYWx3YXlzIGZhaWwgd2l0aCBhIDQwMS5cbiAgICAgICAgdGhpcy5zZW5kVHlwZTFNZXNzYWdlKGh0dHBDbGllbnQsIHJlcXVlc3RJbmZvLCBvYmpzLCBmdW5jdGlvbiAoZXJyLCByZXMpIHtcbiAgICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmluYWxDYWxsYmFjayhlcnIsIG51bGwsIG51bGwpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8vIFdlIGhhdmUgdG8gcmVhZGJvZHkgb24gdGhlIHJlc3BvbnNlIGJlZm9yZSBjb250aW51aW5nIG90aGVyd2lzZSB0aGVyZSBpcyBhIGhhbmcuXG4gICAgICAgICAgICByZXMucmVhZEJvZHkoKS50aGVuKCgpID0+IHtcbiAgICAgICAgICAgICAgICAvLyBJdCBpcyBjcml0aWNhbCB0aGF0IHdlIGhhdmUgc2V0SW1tZWRpYXRlIGhlcmUgZHVlIHRvIGhvdyBjb25uZWN0aW9uIHJlcXVlc3RzIGFyZSBxdWV1ZWQuXG4gICAgICAgICAgICAgICAgLy8gSWYgc2V0SW1tZWRpYXRlIGlzIHJlbW92ZWQgdGhlbiB0aGUgTlRMTSBoYW5kc2hha2Ugd2lsbCBub3Qgd29yay5cbiAgICAgICAgICAgICAgICAvLyBzZXRJbW1lZGlhdGUgYWxsb3dzIHVzIHRvIHF1ZXVlIGEgc2Vjb25kIHJlcXVlc3Qgb24gdGhlIHNhbWUgY29ubmVjdGlvbi4gSWYgdGhpcyBzZWNvbmRcbiAgICAgICAgICAgICAgICAvLyByZXF1ZXN0IGlzIG5vdCBxdWV1ZWQgb24gdGhlIGNvbm5lY3Rpb24gd2hlbiB0aGUgZmlyc3QgcmVxdWVzdCBmaW5pc2hlcyB0aGVuIG5vZGUgY2xvc2VzXG4gICAgICAgICAgICAgICAgLy8gdGhlIGNvbm5lY3Rpb24uIE5UTE0gcmVxdWlyZXMgYm90aCByZXF1ZXN0cyB0byBiZSBvbiB0aGUgc2FtZSBjb25uZWN0aW9uIHNvIHdlIG5lZWQgdGhpcy5cbiAgICAgICAgICAgICAgICBzZXRJbW1lZGlhdGUoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICBzZWxmLnNlbmRUeXBlM01lc3NhZ2UoaHR0cENsaWVudCwgcmVxdWVzdEluZm8sIG9ianMsIHJlcywgZmluYWxDYWxsYmFjayk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8vIFRoZSBmb2xsb3dpbmcgbWV0aG9kIGlzIGFuIGFkYXB0YXRpb24gb2YgY29kZSBmb3VuZCBhdCBodHRwczovL2dpdGh1Yi5jb20vU2FtRGVjcm9jay9ub2RlLWh0dHAtbnRsbS9ibG9iL21hc3Rlci9odHRwbnRsbS5qc1xuICAgIHNlbmRUeXBlMU1lc3NhZ2UoaHR0cENsaWVudCwgcmVxdWVzdEluZm8sIG9ianMsIGZpbmFsQ2FsbGJhY2spIHtcbiAgICAgICAgY29uc3QgdHlwZTFIZXhCdWZmZXIgPSBudGxtLmVuY29kZVR5cGUxKHRoaXMuX250bG1PcHRpb25zLndvcmtzdGF0aW9uLCB0aGlzLl9udGxtT3B0aW9ucy5kb21haW4pO1xuICAgICAgICBjb25zdCB0eXBlMW1zZyA9IGBOVExNICR7dHlwZTFIZXhCdWZmZXIudG9TdHJpbmcoJ2Jhc2U2NCcpfWA7XG4gICAgICAgIGNvbnN0IHR5cGUxb3B0aW9ucyA9IHtcbiAgICAgICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICAgICAgICAnQ29ubmVjdGlvbic6ICdrZWVwLWFsaXZlJyxcbiAgICAgICAgICAgICAgICAnQXV0aG9yaXphdGlvbic6IHR5cGUxbXNnXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgdGltZW91dDogcmVxdWVzdEluZm8ub3B0aW9ucy50aW1lb3V0IHx8IDAsXG4gICAgICAgICAgICBhZ2VudDogcmVxdWVzdEluZm8uaHR0cE1vZHVsZSxcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgdHlwZTFpbmZvID0ge307XG4gICAgICAgIHR5cGUxaW5mby5odHRwTW9kdWxlID0gcmVxdWVzdEluZm8uaHR0cE1vZHVsZTtcbiAgICAgICAgdHlwZTFpbmZvLnBhcnNlZFVybCA9IHJlcXVlc3RJbmZvLnBhcnNlZFVybDtcbiAgICAgICAgdHlwZTFpbmZvLm9wdGlvbnMgPSBfLmV4dGVuZCh0eXBlMW9wdGlvbnMsIF8ub21pdChyZXF1ZXN0SW5mby5vcHRpb25zLCAnaGVhZGVycycpKTtcbiAgICAgICAgcmV0dXJuIGh0dHBDbGllbnQucmVxdWVzdFJhd1dpdGhDYWxsYmFjayh0eXBlMWluZm8sIG9ianMsIGZpbmFsQ2FsbGJhY2spO1xuICAgIH1cbiAgICAvLyBUaGUgZm9sbG93aW5nIG1ldGhvZCBpcyBhbiBhZGFwdGF0aW9uIG9mIGNvZGUgZm91bmQgYXQgaHR0cHM6Ly9naXRodWIuY29tL1NhbURlY3JvY2svbm9kZS1odHRwLW50bG0vYmxvYi9tYXN0ZXIvaHR0cG50bG0uanNcbiAgICBzZW5kVHlwZTNNZXNzYWdlKGh0dHBDbGllbnQsIHJlcXVlc3RJbmZvLCBvYmpzLCByZXMsIGNhbGxiYWNrKSB7XG4gICAgICAgIGlmICghcmVzLm1lc3NhZ2UuaGVhZGVycyAmJiAhcmVzLm1lc3NhZ2UuaGVhZGVyc1snd3d3LWF1dGhlbnRpY2F0ZSddKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3d3dy1hdXRoZW50aWNhdGUgbm90IGZvdW5kIG9uIHJlc3BvbnNlIG9mIHNlY29uZCByZXF1ZXN0Jyk7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNlcnZlciB3aWxsIHJlc3BvbmQgd2l0aCBjaGFsbGVuZ2Uvbm9uY2VcbiAgICAgICAgICogYXNzaWduZWQgdG8gcmVzcG9uc2UncyBcIldXVy1BVVRIRU5USUNBVEVcIiBoZWFkZXJcbiAgICAgICAgICogYW5kIHNob3VsZCBhZGhlcmUgdG8gUmVnRXhwIC9eTlRMTVxccysoLis/KSgsfFxccyt8JCkvXG4gICAgICAgICAqL1xuICAgICAgICBjb25zdCBzZXJ2ZXJOb25jZVJlZ2V4ID0gL15OVExNXFxzKyguKz8pKCx8XFxzK3wkKS87XG4gICAgICAgIGNvbnN0IHNlcnZlck5vbmNlID0gQnVmZmVyLmZyb20oKHJlcy5tZXNzYWdlLmhlYWRlcnNbJ3d3dy1hdXRoZW50aWNhdGUnXS5tYXRjaChzZXJ2ZXJOb25jZVJlZ2V4KSB8fCBbXSlbMV0sICdiYXNlNjQnKTtcbiAgICAgICAgbGV0IHR5cGUybXNnO1xuICAgICAgICAvKipcbiAgICAgICAgICogV3JhcCBkZWNvZGluZyB0aGUgU2VydmVyJ3MgY2hhbGxlbmdlL25vbmNlIGluXG4gICAgICAgICAqIHRyeS1jYXRjaCBibG9jayB0byB0aHJvdyBtb3JlIGNvbXByZWhlbnNpdmVcbiAgICAgICAgICogRXJyb3Igd2l0aCBjbGVhciBtZXNzYWdlIHRvIGNvbnN1bWVyXG4gICAgICAgICAqL1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgdHlwZTJtc2cgPSBudGxtLmRlY29kZVR5cGUyKHNlcnZlck5vbmNlKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgRGVjb2RpbmcgU2VydmVyJ3MgQ2hhbGxlbmdlIHRvIE9idGFpbiBUeXBlMk1lc3NhZ2UgZmFpbGVkIHdpdGggZXJyb3I6ICR7ZXJyb3IubWVzc2FnZX1gKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB0eXBlM21zZyA9IG50bG0uZW5jb2RlVHlwZTModGhpcy5fbnRsbU9wdGlvbnMudXNlcm5hbWUsIHRoaXMuX250bG1PcHRpb25zLndvcmtzdGF0aW9uLCB0aGlzLl9udGxtT3B0aW9ucy5kb21haW4sIHR5cGUybXNnLCB0aGlzLl9udGxtT3B0aW9ucy5wYXNzd29yZCkudG9TdHJpbmcoJ2Jhc2U2NCcpO1xuICAgICAgICBjb25zdCB0eXBlM29wdGlvbnMgPSB7XG4gICAgICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgICAgICAgJ0F1dGhvcml6YXRpb24nOiBgTlRMTSAke3R5cGUzbXNnfWAsXG4gICAgICAgICAgICAgICAgJ0Nvbm5lY3Rpb24nOiAnQ2xvc2UnXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgYWdlbnQ6IHJlcXVlc3RJbmZvLmh0dHBNb2R1bGUsXG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IHR5cGUzaW5mbyA9IHt9O1xuICAgICAgICB0eXBlM2luZm8uaHR0cE1vZHVsZSA9IHJlcXVlc3RJbmZvLmh0dHBNb2R1bGU7XG4gICAgICAgIHR5cGUzaW5mby5wYXJzZWRVcmwgPSByZXF1ZXN0SW5mby5wYXJzZWRVcmw7XG4gICAgICAgIHR5cGUzb3B0aW9ucy5oZWFkZXJzID0gXy5leHRlbmQodHlwZTNvcHRpb25zLmhlYWRlcnMsIHJlcXVlc3RJbmZvLm9wdGlvbnMuaGVhZGVycyk7XG4gICAgICAgIHR5cGUzaW5mby5vcHRpb25zID0gXy5leHRlbmQodHlwZTNvcHRpb25zLCBfLm9taXQocmVxdWVzdEluZm8ub3B0aW9ucywgJ2hlYWRlcnMnKSk7XG4gICAgICAgIHJldHVybiBodHRwQ2xpZW50LnJlcXVlc3RSYXdXaXRoQ2FsbGJhY2sodHlwZTNpbmZvLCBvYmpzLCBjYWxsYmFjayk7XG4gICAgfVxufVxuZXhwb3J0cy5OdGxtQ3JlZGVudGlhbEhhbmRsZXIgPSBOdGxtQ3JlZGVudGlhbEhhbmRsZXI7XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/typed-rest-client/handlers/ntlm.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/typed-rest-client/handlers/personalaccesstoken.js":
/*!************************************************************************!*\
  !*** ./node_modules/typed-rest-client/handlers/personalaccesstoken.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\n// Copyright (c) Microsoft. All rights reserved.\n// Licensed under the MIT license. See LICENSE file in the project root for full license information.\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.PersonalAccessTokenCredentialHandler = void 0;\nclass PersonalAccessTokenCredentialHandler {\n    constructor(token, allowCrossOriginAuthentication) {\n        this.token = token;\n        this.allowCrossOriginAuthentication = allowCrossOriginAuthentication;\n    }\n    // currently implements pre-authorization\n    // TODO: support preAuth = false where it hooks on 401\n    prepareRequest(options) {\n        if (!this.origin) {\n            this.origin = options.host;\n        }\n        // If this is a redirection, don't set the Authorization header\n        if (this.origin === options.host || this.allowCrossOriginAuthentication) {\n            options.headers['Authorization'] = `Basic ${Buffer.from(`PAT:${this.token}`).toString('base64')}`;\n        }\n        options.headers['X-TFS-FedAuthRedirect'] = 'Suppress';\n    }\n    // This handler cannot handle 401\n    canHandleAuthentication(response) {\n        return false;\n    }\n    handleAuthentication(httpClient, requestInfo, objs) {\n        return null;\n    }\n}\nexports.PersonalAccessTokenCredentialHandler = PersonalAccessTokenCredentialHandler;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvdHlwZWQtcmVzdC1jbGllbnQvaGFuZGxlcnMvcGVyc29uYWxhY2Nlc3N0b2tlbi5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsNENBQTRDO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0RBQXdELG1CQUFtQixXQUFXLHNCQUFzQjtBQUM1RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDIiwic291cmNlcyI6WyJDOlxcUHJvamVjdHNcXEJ1aWxkTGF1bmNoZXJUZXN0XFxub2RlX21vZHVsZXNcXHR5cGVkLXJlc3QtY2xpZW50XFxoYW5kbGVyc1xccGVyc29uYWxhY2Nlc3N0b2tlbi5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbi8vIENvcHlyaWdodCAoYykgTWljcm9zb2Z0LiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuLy8gTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlLiBTZWUgTElDRU5TRSBmaWxlIGluIHRoZSBwcm9qZWN0IHJvb3QgZm9yIGZ1bGwgbGljZW5zZSBpbmZvcm1hdGlvbi5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuUGVyc29uYWxBY2Nlc3NUb2tlbkNyZWRlbnRpYWxIYW5kbGVyID0gdm9pZCAwO1xuY2xhc3MgUGVyc29uYWxBY2Nlc3NUb2tlbkNyZWRlbnRpYWxIYW5kbGVyIHtcbiAgICBjb25zdHJ1Y3Rvcih0b2tlbiwgYWxsb3dDcm9zc09yaWdpbkF1dGhlbnRpY2F0aW9uKSB7XG4gICAgICAgIHRoaXMudG9rZW4gPSB0b2tlbjtcbiAgICAgICAgdGhpcy5hbGxvd0Nyb3NzT3JpZ2luQXV0aGVudGljYXRpb24gPSBhbGxvd0Nyb3NzT3JpZ2luQXV0aGVudGljYXRpb247XG4gICAgfVxuICAgIC8vIGN1cnJlbnRseSBpbXBsZW1lbnRzIHByZS1hdXRob3JpemF0aW9uXG4gICAgLy8gVE9ETzogc3VwcG9ydCBwcmVBdXRoID0gZmFsc2Ugd2hlcmUgaXQgaG9va3Mgb24gNDAxXG4gICAgcHJlcGFyZVJlcXVlc3Qob3B0aW9ucykge1xuICAgICAgICBpZiAoIXRoaXMub3JpZ2luKSB7XG4gICAgICAgICAgICB0aGlzLm9yaWdpbiA9IG9wdGlvbnMuaG9zdDtcbiAgICAgICAgfVxuICAgICAgICAvLyBJZiB0aGlzIGlzIGEgcmVkaXJlY3Rpb24sIGRvbid0IHNldCB0aGUgQXV0aG9yaXphdGlvbiBoZWFkZXJcbiAgICAgICAgaWYgKHRoaXMub3JpZ2luID09PSBvcHRpb25zLmhvc3QgfHwgdGhpcy5hbGxvd0Nyb3NzT3JpZ2luQXV0aGVudGljYXRpb24pIHtcbiAgICAgICAgICAgIG9wdGlvbnMuaGVhZGVyc1snQXV0aG9yaXphdGlvbiddID0gYEJhc2ljICR7QnVmZmVyLmZyb20oYFBBVDoke3RoaXMudG9rZW59YCkudG9TdHJpbmcoJ2Jhc2U2NCcpfWA7XG4gICAgICAgIH1cbiAgICAgICAgb3B0aW9ucy5oZWFkZXJzWydYLVRGUy1GZWRBdXRoUmVkaXJlY3QnXSA9ICdTdXBwcmVzcyc7XG4gICAgfVxuICAgIC8vIFRoaXMgaGFuZGxlciBjYW5ub3QgaGFuZGxlIDQwMVxuICAgIGNhbkhhbmRsZUF1dGhlbnRpY2F0aW9uKHJlc3BvbnNlKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaGFuZGxlQXV0aGVudGljYXRpb24oaHR0cENsaWVudCwgcmVxdWVzdEluZm8sIG9ianMpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxufVxuZXhwb3J0cy5QZXJzb25hbEFjY2Vzc1Rva2VuQ3JlZGVudGlhbEhhbmRsZXIgPSBQZXJzb25hbEFjY2Vzc1Rva2VuQ3JlZGVudGlhbEhhbmRsZXI7XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/typed-rest-client/handlers/personalaccesstoken.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/typed-rest-client/opensource/Node-SMB/lib/common.js":
/*!**************************************************************************!*\
  !*** ./node_modules/typed-rest-client/opensource/Node-SMB/lib/common.js ***!
  \**************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("var crypto = __webpack_require__(/*! crypto */ \"crypto\");\n\nfunction zeroextend(str, len)\n{\n  while (str.length < len)\n    str = '0' + str;\n  return (str);\n}\n\n/*\n * Fix (odd) parity bits in a 64-bit DES key.\n */\nfunction oddpar(buf)\n{\n  for (var j = 0; j < buf.length; j++) {\n    var par = 1;\n    for (var i = 1; i < 8; i++) {\n      par = (par + ((buf[j] >> i) & 1)) % 2;\n    }\n    buf[j] |= par & 1;\n  }\n  return buf;\n}\n\n/*\n * Expand a 56-bit key buffer to the full 64-bits for DES.\n *\n * Based on code sample in:\n *    http://www.innovation.ch/personal/ronald/ntlm.html\n */\nfunction expandkey(key56)\n{\n  var key64 = Buffer.alloc(8);\n\n  key64[0] = key56[0] & 0xFE;\n  key64[1] = ((key56[0] << 7) & 0xFF) | (key56[1] >> 1);\n  key64[2] = ((key56[1] << 6) & 0xFF) | (key56[2] >> 2);\n  key64[3] = ((key56[2] << 5) & 0xFF) | (key56[3] >> 3);\n  key64[4] = ((key56[3] << 4) & 0xFF) | (key56[4] >> 4);\n  key64[5] = ((key56[4] << 3) & 0xFF) | (key56[5] >> 5);\n  key64[6] = ((key56[5] << 2) & 0xFF) | (key56[6] >> 6);\n  key64[7] =  (key56[6] << 1) & 0xFF;\n\n  return key64;\n}\n\n/*\n * Convert a binary string to a hex string\n */\nfunction bintohex(bin)\n{\n  var buf = (Buffer.isBuffer(buf) ? buf : Buffer.from(bin, 'binary'));\n  var str = buf.toString('hex').toUpperCase();\n  return zeroextend(str, 32);\n}\n\n\nmodule.exports.zeroextend = zeroextend;\nmodule.exports.oddpar = oddpar;\nmodule.exports.expandkey = expandkey;\nmodule.exports.bintohex = bintohex;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvdHlwZWQtcmVzdC1jbGllbnQvb3BlbnNvdXJjZS9Ob2RlLVNNQi9saWIvY29tbW9uLmpzIiwibWFwcGluZ3MiOiJBQUFBLGFBQWEsbUJBQU8sQ0FBQyxzQkFBUTs7QUFFN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsZ0JBQWdCO0FBQ2xDO0FBQ0Esb0JBQW9CLE9BQU87QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQSx5QkFBeUI7QUFDekIscUJBQXFCO0FBQ3JCLHdCQUF3QjtBQUN4Qix1QkFBdUIiLCJzb3VyY2VzIjpbIkM6XFxQcm9qZWN0c1xcQnVpbGRMYXVuY2hlclRlc3RcXG5vZGVfbW9kdWxlc1xcdHlwZWQtcmVzdC1jbGllbnRcXG9wZW5zb3VyY2VcXE5vZGUtU01CXFxsaWJcXGNvbW1vbi5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgY3J5cHRvID0gcmVxdWlyZSgnY3J5cHRvJyk7XG5cbmZ1bmN0aW9uIHplcm9leHRlbmQoc3RyLCBsZW4pXG57XG4gIHdoaWxlIChzdHIubGVuZ3RoIDwgbGVuKVxuICAgIHN0ciA9ICcwJyArIHN0cjtcbiAgcmV0dXJuIChzdHIpO1xufVxuXG4vKlxuICogRml4IChvZGQpIHBhcml0eSBiaXRzIGluIGEgNjQtYml0IERFUyBrZXkuXG4gKi9cbmZ1bmN0aW9uIG9kZHBhcihidWYpXG57XG4gIGZvciAodmFyIGogPSAwOyBqIDwgYnVmLmxlbmd0aDsgaisrKSB7XG4gICAgdmFyIHBhciA9IDE7XG4gICAgZm9yICh2YXIgaSA9IDE7IGkgPCA4OyBpKyspIHtcbiAgICAgIHBhciA9IChwYXIgKyAoKGJ1ZltqXSA+PiBpKSAmIDEpKSAlIDI7XG4gICAgfVxuICAgIGJ1ZltqXSB8PSBwYXIgJiAxO1xuICB9XG4gIHJldHVybiBidWY7XG59XG5cbi8qXG4gKiBFeHBhbmQgYSA1Ni1iaXQga2V5IGJ1ZmZlciB0byB0aGUgZnVsbCA2NC1iaXRzIGZvciBERVMuXG4gKlxuICogQmFzZWQgb24gY29kZSBzYW1wbGUgaW46XG4gKiAgICBodHRwOi8vd3d3Lmlubm92YXRpb24uY2gvcGVyc29uYWwvcm9uYWxkL250bG0uaHRtbFxuICovXG5mdW5jdGlvbiBleHBhbmRrZXkoa2V5NTYpXG57XG4gIHZhciBrZXk2NCA9IEJ1ZmZlci5hbGxvYyg4KTtcblxuICBrZXk2NFswXSA9IGtleTU2WzBdICYgMHhGRTtcbiAga2V5NjRbMV0gPSAoKGtleTU2WzBdIDw8IDcpICYgMHhGRikgfCAoa2V5NTZbMV0gPj4gMSk7XG4gIGtleTY0WzJdID0gKChrZXk1NlsxXSA8PCA2KSAmIDB4RkYpIHwgKGtleTU2WzJdID4+IDIpO1xuICBrZXk2NFszXSA9ICgoa2V5NTZbMl0gPDwgNSkgJiAweEZGKSB8IChrZXk1NlszXSA+PiAzKTtcbiAga2V5NjRbNF0gPSAoKGtleTU2WzNdIDw8IDQpICYgMHhGRikgfCAoa2V5NTZbNF0gPj4gNCk7XG4gIGtleTY0WzVdID0gKChrZXk1Nls0XSA8PCAzKSAmIDB4RkYpIHwgKGtleTU2WzVdID4+IDUpO1xuICBrZXk2NFs2XSA9ICgoa2V5NTZbNV0gPDwgMikgJiAweEZGKSB8IChrZXk1Nls2XSA+PiA2KTtcbiAga2V5NjRbN10gPSAgKGtleTU2WzZdIDw8IDEpICYgMHhGRjtcblxuICByZXR1cm4ga2V5NjQ7XG59XG5cbi8qXG4gKiBDb252ZXJ0IGEgYmluYXJ5IHN0cmluZyB0byBhIGhleCBzdHJpbmdcbiAqL1xuZnVuY3Rpb24gYmludG9oZXgoYmluKVxue1xuICB2YXIgYnVmID0gKEJ1ZmZlci5pc0J1ZmZlcihidWYpID8gYnVmIDogQnVmZmVyLmZyb20oYmluLCAnYmluYXJ5JykpO1xuICB2YXIgc3RyID0gYnVmLnRvU3RyaW5nKCdoZXgnKS50b1VwcGVyQ2FzZSgpO1xuICByZXR1cm4gemVyb2V4dGVuZChzdHIsIDMyKTtcbn1cblxuXG5tb2R1bGUuZXhwb3J0cy56ZXJvZXh0ZW5kID0gemVyb2V4dGVuZDtcbm1vZHVsZS5leHBvcnRzLm9kZHBhciA9IG9kZHBhcjtcbm1vZHVsZS5leHBvcnRzLmV4cGFuZGtleSA9IGV4cGFuZGtleTtcbm1vZHVsZS5leHBvcnRzLmJpbnRvaGV4ID0gYmludG9oZXg7XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/typed-rest-client/opensource/Node-SMB/lib/common.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/typed-rest-client/opensource/Node-SMB/lib/ntlm.js":
/*!************************************************************************!*\
  !*** ./node_modules/typed-rest-client/opensource/Node-SMB/lib/ntlm.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("var log = console.log;\nvar crypto = __webpack_require__(/*! crypto */ \"crypto\");\nvar $ = __webpack_require__(/*! ./common */ \"(rsc)/./node_modules/typed-rest-client/opensource/Node-SMB/lib/common.js\");\nvar lmhashbuf = (__webpack_require__(/*! ./smbhash */ \"(rsc)/./node_modules/typed-rest-client/opensource/Node-SMB/lib/smbhash.js\").lmhashbuf);\nvar nthashbuf = (__webpack_require__(/*! ./smbhash */ \"(rsc)/./node_modules/typed-rest-client/opensource/Node-SMB/lib/smbhash.js\").nthashbuf);\n\nvar desjs = __webpack_require__(/*! des.js */ \"(rsc)/./node_modules/des.js/lib/des.js\");\n\nfunction encodeType1(hostname, ntdomain) {\n  hostname = hostname.toUpperCase();\n  ntdomain = ntdomain.toUpperCase();\n  var hostnamelen = Buffer.byteLength(hostname, 'ascii');\n  var ntdomainlen = Buffer.byteLength(ntdomain, 'ascii');\n\n  var pos = 0;\n  var buf = Buffer.alloc(32 + hostnamelen + ntdomainlen);\n\n  buf.write('NTLMSSP', pos, 7, 'ascii'); // byte protocol[8];\n  pos += 7;\n  buf.writeUInt8(0, pos);\n  pos++;\n\n  buf.writeUInt8(0x01, pos); // byte type;\n  pos++;\n\n  buf.fill(0x00, pos, pos + 3); // byte zero[3];\n  pos += 3;\n\n  buf.writeUInt16LE(0xb203, pos); // short flags;\n  pos += 2;\n\n  buf.fill(0x00, pos, pos + 2); // byte zero[2];\n  pos += 2;\n\n  buf.writeUInt16LE(ntdomainlen, pos); // short dom_len;\n  pos += 2;\n  buf.writeUInt16LE(ntdomainlen, pos); // short dom_len;\n  pos += 2;\n\n  var ntdomainoff = 0x20 + hostnamelen;\n  buf.writeUInt16LE(ntdomainoff, pos); // short dom_off;\n  pos += 2;\n\n  buf.fill(0x00, pos, pos + 2); // byte zero[2];\n  pos += 2;\n\n  buf.writeUInt16LE(hostnamelen, pos); // short host_len;\n  pos += 2;\n  buf.writeUInt16LE(hostnamelen, pos); // short host_len;\n  pos += 2;\n\n  buf.writeUInt16LE(0x20, pos); // short host_off;\n  pos += 2;\n\n  buf.fill(0x00, pos, pos + 2); // byte zero[2];\n  pos += 2;\n\n  buf.write(hostname, 0x20, hostnamelen, 'ascii');\n  buf.write(ntdomain, ntdomainoff, ntdomainlen, 'ascii');\n\n  return buf;\n}\n\n\n/*\n * \n */\nfunction decodeType2(buf)\n{\n  var proto = buf.toString('ascii', 0, 7);\n  if (buf[7] !== 0x00 || proto !== 'NTLMSSP')\n    throw new Error('magic was not NTLMSSP');\n\n  var type = buf.readUInt8(8);\n  if (type !== 0x02)\n    throw new Error('message was not NTLMSSP type 0x02');\n\n  //var msg_len = buf.readUInt16LE(16);\n\n  //var flags = buf.readUInt16LE(20);\n\n  var nonce = buf.slice(24, 32);\n  return nonce;\n}\n\nfunction encodeType3(username, hostname, ntdomain, nonce, password) {\n  hostname = hostname.toUpperCase();\n  ntdomain = ntdomain.toUpperCase();\n\n  var lmh = Buffer.alloc(21);\n  lmhashbuf(password).copy(lmh);\n  lmh.fill(0x00, 16); // null pad to 21 bytes\n  var nth = Buffer.alloc(21);\n  nthashbuf(password).copy(nth);\n  nth.fill(0x00, 16); // null pad to 21 bytes\n\n  var lmr = makeResponse(lmh, nonce);\n  var ntr = makeResponse(nth, nonce);\n\n  var usernamelen = Buffer.byteLength(username, 'ucs2');\n  var hostnamelen = Buffer.byteLength(hostname, 'ucs2');\n  var ntdomainlen = Buffer.byteLength(ntdomain, 'ucs2');\n  var lmrlen = 0x18;\n  var ntrlen = 0x18;\n\n  var ntdomainoff = 0x40;\n  var usernameoff = ntdomainoff + ntdomainlen;\n  var hostnameoff = usernameoff + usernamelen;\n  var lmroff = hostnameoff + hostnamelen;\n  var ntroff = lmroff + lmrlen;\n\n  var pos = 0;\n  var msg_len = 64 + ntdomainlen + usernamelen + hostnamelen + lmrlen + ntrlen;\n  var buf = Buffer.alloc(msg_len);\n\n  buf.write('NTLMSSP', pos, 7, 'ascii'); // byte protocol[8];\n  pos += 7;\n  buf.writeUInt8(0, pos);\n  pos++;\n\n  buf.writeUInt8(0x03, pos); // byte type;\n  pos++;\n\n  buf.fill(0x00, pos, pos + 3); // byte zero[3];\n  pos += 3;\n\n  buf.writeUInt16LE(lmrlen, pos); // short lm_resp_len;\n  pos += 2;\n  buf.writeUInt16LE(lmrlen, pos); // short lm_resp_len;\n  pos += 2;\n  buf.writeUInt16LE(lmroff, pos); // short lm_resp_off;\n  pos += 2;\n  buf.fill(0x00, pos, pos + 2); // byte zero[2];\n  pos += 2;\n\n  buf.writeUInt16LE(ntrlen, pos); // short nt_resp_len;\n  pos += 2;\n  buf.writeUInt16LE(ntrlen, pos); // short nt_resp_len;\n  pos += 2;\n  buf.writeUInt16LE(ntroff, pos); // short nt_resp_off;\n  pos += 2;\n  buf.fill(0x00, pos, pos + 2); // byte zero[2];\n  pos += 2;\n\n  buf.writeUInt16LE(ntdomainlen, pos); // short dom_len;\n  pos += 2;\n  buf.writeUInt16LE(ntdomainlen, pos); // short dom_len;\n  pos += 2;\n  buf.writeUInt16LE(ntdomainoff, pos); // short dom_off;\n  pos += 2;\n  buf.fill(0x00, pos, pos + 2); // byte zero[2];\n  pos += 2;\n\n  buf.writeUInt16LE(usernamelen, pos); // short user_len;\n  pos += 2;\n  buf.writeUInt16LE(usernamelen, pos); // short user_len;\n  pos += 2;\n  buf.writeUInt16LE(usernameoff, pos); // short user_off;\n  pos += 2;\n  buf.fill(0x00, pos, pos + 2); // byte zero[2];\n  pos += 2;\n\n  buf.writeUInt16LE(hostnamelen, pos); // short host_len;\n  pos += 2;\n  buf.writeUInt16LE(hostnamelen, pos); // short host_len;\n  pos += 2;\n  buf.writeUInt16LE(hostnameoff, pos); // short host_off;\n  pos += 2;\n  buf.fill(0x00, pos, pos + 6); // byte zero[6];\n  pos += 6;\n\n  buf.writeUInt16LE(msg_len, pos); // short msg_len;\n  pos += 2;\n  buf.fill(0x00, pos, pos + 2); // byte zero[2];\n  pos += 2;\n\n  buf.writeUInt16LE(0x8201, pos); // short flags;\n  pos += 2;\n  buf.fill(0x00, pos, pos + 2); // byte zero[2];\n  pos += 2;\n\n  buf.write(ntdomain, ntdomainoff, ntdomainlen, 'ucs2');\n  buf.write(username, usernameoff, usernamelen, 'ucs2');\n  buf.write(hostname, hostnameoff, hostnamelen, 'ucs2');\n  lmr.copy(buf, lmroff, 0, lmrlen);\n  ntr.copy(buf, ntroff, 0, ntrlen);\n\n  return buf;\n}\n\nfunction makeResponse(hash, nonce)\n{\n  var out = Buffer.alloc(24);\n\n  for (var i = 0; i < 3; i++) {\n    var keybuf = $.oddpar($.expandkey(hash.slice(i * 7, i * 7 + 7)));\n\n    var des = desjs.DES.create({type: 'encrypt', key: keybuf});\n    var magicKey = Buffer.from(nonce.toString('binary'));\n    var insertBuff = Buffer.from(des.update(magicKey));\n\n    out.fill(insertBuff, i * 8, i * 8 + 8, 'binary');\n    \n  }\n  return out;\n}\n\nexports.encodeType1 = encodeType1;\nexports.decodeType2 = decodeType2;\nexports.encodeType3 = encodeType3;\n\n// Convenience methods.\n\nexports.challengeHeader = function (hostname, domain) {\n  return 'NTLM ' + exports.encodeType1(hostname, domain).toString('base64');\n};\n\nexports.responseHeader = function (res, url, domain, username, password) {\n  var serverNonce = Buffer.from((res.headers['www-authenticate'].match(/^NTLM\\s+(.+?)(,|\\s+|$)/) || [])[1], 'base64');\n  var hostname = (__webpack_require__(/*! url */ \"url\").parse)(url).hostname;\n  return 'NTLM ' + exports.encodeType3(username, hostname, domain, exports.decodeType2(serverNonce), password).toString('base64')\n};\n\n// Import smbhash module.\n\nexports.smbhash = __webpack_require__(/*! ./smbhash */ \"(rsc)/./node_modules/typed-rest-client/opensource/Node-SMB/lib/smbhash.js\");\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvdHlwZWQtcmVzdC1jbGllbnQvb3BlbnNvdXJjZS9Ob2RlLVNNQi9saWIvbnRsbS5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBLGFBQWEsbUJBQU8sQ0FBQyxzQkFBUTtBQUM3QixRQUFRLG1CQUFPLENBQUMsMEZBQVU7QUFDMUIsZ0JBQWdCLDZIQUE4QjtBQUM5QyxnQkFBZ0IsNkhBQThCOztBQUU5QyxZQUFZLG1CQUFPLENBQUMsc0RBQVE7O0FBRTVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSx5Q0FBeUM7QUFDekM7QUFDQTtBQUNBOztBQUVBLDZCQUE2QjtBQUM3Qjs7QUFFQSxnQ0FBZ0M7QUFDaEM7O0FBRUEsa0NBQWtDO0FBQ2xDOztBQUVBLGdDQUFnQztBQUNoQzs7QUFFQSx1Q0FBdUM7QUFDdkM7QUFDQSx1Q0FBdUM7QUFDdkM7O0FBRUE7QUFDQSx1Q0FBdUM7QUFDdkM7O0FBRUEsZ0NBQWdDO0FBQ2hDOztBQUVBLHVDQUF1QztBQUN2QztBQUNBLHVDQUF1QztBQUN2Qzs7QUFFQSxnQ0FBZ0M7QUFDaEM7O0FBRUEsZ0NBQWdDO0FBQ2hDOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQSxzQkFBc0I7O0FBRXRCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSx5Q0FBeUM7QUFDekM7QUFDQTtBQUNBOztBQUVBLDZCQUE2QjtBQUM3Qjs7QUFFQSxnQ0FBZ0M7QUFDaEM7O0FBRUEsa0NBQWtDO0FBQ2xDO0FBQ0Esa0NBQWtDO0FBQ2xDO0FBQ0Esa0NBQWtDO0FBQ2xDO0FBQ0EsZ0NBQWdDO0FBQ2hDOztBQUVBLGtDQUFrQztBQUNsQztBQUNBLGtDQUFrQztBQUNsQztBQUNBLGtDQUFrQztBQUNsQztBQUNBLGdDQUFnQztBQUNoQzs7QUFFQSx1Q0FBdUM7QUFDdkM7QUFDQSx1Q0FBdUM7QUFDdkM7QUFDQSx1Q0FBdUM7QUFDdkM7QUFDQSxnQ0FBZ0M7QUFDaEM7O0FBRUEsdUNBQXVDO0FBQ3ZDO0FBQ0EsdUNBQXVDO0FBQ3ZDO0FBQ0EsdUNBQXVDO0FBQ3ZDO0FBQ0EsZ0NBQWdDO0FBQ2hDOztBQUVBLHVDQUF1QztBQUN2QztBQUNBLHVDQUF1QztBQUN2QztBQUNBLHVDQUF1QztBQUN2QztBQUNBLGdDQUFnQztBQUNoQzs7QUFFQSxtQ0FBbUM7QUFDbkM7QUFDQSxnQ0FBZ0M7QUFDaEM7O0FBRUEsa0NBQWtDO0FBQ2xDO0FBQ0EsZ0NBQWdDO0FBQ2hDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsa0JBQWtCLE9BQU87QUFDekI7O0FBRUEsZ0NBQWdDLDZCQUE2QjtBQUM3RDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsbUJBQW1CO0FBQ25CLG1CQUFtQjtBQUNuQixtQkFBbUI7O0FBRW5COztBQUVBLHVCQUF1QjtBQUN2QjtBQUNBOztBQUVBLHNCQUFzQjtBQUN0QjtBQUNBLGlCQUFpQiw2Q0FBb0I7QUFDckM7QUFDQTs7QUFFQTs7QUFFQSxtSUFBc0MiLCJzb3VyY2VzIjpbIkM6XFxQcm9qZWN0c1xcQnVpbGRMYXVuY2hlclRlc3RcXG5vZGVfbW9kdWxlc1xcdHlwZWQtcmVzdC1jbGllbnRcXG9wZW5zb3VyY2VcXE5vZGUtU01CXFxsaWJcXG50bG0uanMiXSwic291cmNlc0NvbnRlbnQiOlsidmFyIGxvZyA9IGNvbnNvbGUubG9nO1xudmFyIGNyeXB0byA9IHJlcXVpcmUoJ2NyeXB0bycpO1xudmFyICQgPSByZXF1aXJlKCcuL2NvbW1vbicpO1xudmFyIGxtaGFzaGJ1ZiA9IHJlcXVpcmUoJy4vc21iaGFzaCcpLmxtaGFzaGJ1ZjtcbnZhciBudGhhc2hidWYgPSByZXF1aXJlKCcuL3NtYmhhc2gnKS5udGhhc2hidWY7XG5cbnZhciBkZXNqcyA9IHJlcXVpcmUoXCJkZXMuanNcIik7XG5cbmZ1bmN0aW9uIGVuY29kZVR5cGUxKGhvc3RuYW1lLCBudGRvbWFpbikge1xuICBob3N0bmFtZSA9IGhvc3RuYW1lLnRvVXBwZXJDYXNlKCk7XG4gIG50ZG9tYWluID0gbnRkb21haW4udG9VcHBlckNhc2UoKTtcbiAgdmFyIGhvc3RuYW1lbGVuID0gQnVmZmVyLmJ5dGVMZW5ndGgoaG9zdG5hbWUsICdhc2NpaScpO1xuICB2YXIgbnRkb21haW5sZW4gPSBCdWZmZXIuYnl0ZUxlbmd0aChudGRvbWFpbiwgJ2FzY2lpJyk7XG5cbiAgdmFyIHBvcyA9IDA7XG4gIHZhciBidWYgPSBCdWZmZXIuYWxsb2MoMzIgKyBob3N0bmFtZWxlbiArIG50ZG9tYWlubGVuKTtcblxuICBidWYud3JpdGUoJ05UTE1TU1AnLCBwb3MsIDcsICdhc2NpaScpOyAvLyBieXRlIHByb3RvY29sWzhdO1xuICBwb3MgKz0gNztcbiAgYnVmLndyaXRlVUludDgoMCwgcG9zKTtcbiAgcG9zKys7XG5cbiAgYnVmLndyaXRlVUludDgoMHgwMSwgcG9zKTsgLy8gYnl0ZSB0eXBlO1xuICBwb3MrKztcblxuICBidWYuZmlsbCgweDAwLCBwb3MsIHBvcyArIDMpOyAvLyBieXRlIHplcm9bM107XG4gIHBvcyArPSAzO1xuXG4gIGJ1Zi53cml0ZVVJbnQxNkxFKDB4YjIwMywgcG9zKTsgLy8gc2hvcnQgZmxhZ3M7XG4gIHBvcyArPSAyO1xuXG4gIGJ1Zi5maWxsKDB4MDAsIHBvcywgcG9zICsgMik7IC8vIGJ5dGUgemVyb1syXTtcbiAgcG9zICs9IDI7XG5cbiAgYnVmLndyaXRlVUludDE2TEUobnRkb21haW5sZW4sIHBvcyk7IC8vIHNob3J0IGRvbV9sZW47XG4gIHBvcyArPSAyO1xuICBidWYud3JpdGVVSW50MTZMRShudGRvbWFpbmxlbiwgcG9zKTsgLy8gc2hvcnQgZG9tX2xlbjtcbiAgcG9zICs9IDI7XG5cbiAgdmFyIG50ZG9tYWlub2ZmID0gMHgyMCArIGhvc3RuYW1lbGVuO1xuICBidWYud3JpdGVVSW50MTZMRShudGRvbWFpbm9mZiwgcG9zKTsgLy8gc2hvcnQgZG9tX29mZjtcbiAgcG9zICs9IDI7XG5cbiAgYnVmLmZpbGwoMHgwMCwgcG9zLCBwb3MgKyAyKTsgLy8gYnl0ZSB6ZXJvWzJdO1xuICBwb3MgKz0gMjtcblxuICBidWYud3JpdGVVSW50MTZMRShob3N0bmFtZWxlbiwgcG9zKTsgLy8gc2hvcnQgaG9zdF9sZW47XG4gIHBvcyArPSAyO1xuICBidWYud3JpdGVVSW50MTZMRShob3N0bmFtZWxlbiwgcG9zKTsgLy8gc2hvcnQgaG9zdF9sZW47XG4gIHBvcyArPSAyO1xuXG4gIGJ1Zi53cml0ZVVJbnQxNkxFKDB4MjAsIHBvcyk7IC8vIHNob3J0IGhvc3Rfb2ZmO1xuICBwb3MgKz0gMjtcblxuICBidWYuZmlsbCgweDAwLCBwb3MsIHBvcyArIDIpOyAvLyBieXRlIHplcm9bMl07XG4gIHBvcyArPSAyO1xuXG4gIGJ1Zi53cml0ZShob3N0bmFtZSwgMHgyMCwgaG9zdG5hbWVsZW4sICdhc2NpaScpO1xuICBidWYud3JpdGUobnRkb21haW4sIG50ZG9tYWlub2ZmLCBudGRvbWFpbmxlbiwgJ2FzY2lpJyk7XG5cbiAgcmV0dXJuIGJ1Zjtcbn1cblxuXG4vKlxuICogXG4gKi9cbmZ1bmN0aW9uIGRlY29kZVR5cGUyKGJ1ZilcbntcbiAgdmFyIHByb3RvID0gYnVmLnRvU3RyaW5nKCdhc2NpaScsIDAsIDcpO1xuICBpZiAoYnVmWzddICE9PSAweDAwIHx8IHByb3RvICE9PSAnTlRMTVNTUCcpXG4gICAgdGhyb3cgbmV3IEVycm9yKCdtYWdpYyB3YXMgbm90IE5UTE1TU1AnKTtcblxuICB2YXIgdHlwZSA9IGJ1Zi5yZWFkVUludDgoOCk7XG4gIGlmICh0eXBlICE9PSAweDAyKVxuICAgIHRocm93IG5ldyBFcnJvcignbWVzc2FnZSB3YXMgbm90IE5UTE1TU1AgdHlwZSAweDAyJyk7XG5cbiAgLy92YXIgbXNnX2xlbiA9IGJ1Zi5yZWFkVUludDE2TEUoMTYpO1xuXG4gIC8vdmFyIGZsYWdzID0gYnVmLnJlYWRVSW50MTZMRSgyMCk7XG5cbiAgdmFyIG5vbmNlID0gYnVmLnNsaWNlKDI0LCAzMik7XG4gIHJldHVybiBub25jZTtcbn1cblxuZnVuY3Rpb24gZW5jb2RlVHlwZTModXNlcm5hbWUsIGhvc3RuYW1lLCBudGRvbWFpbiwgbm9uY2UsIHBhc3N3b3JkKSB7XG4gIGhvc3RuYW1lID0gaG9zdG5hbWUudG9VcHBlckNhc2UoKTtcbiAgbnRkb21haW4gPSBudGRvbWFpbi50b1VwcGVyQ2FzZSgpO1xuXG4gIHZhciBsbWggPSBCdWZmZXIuYWxsb2MoMjEpO1xuICBsbWhhc2hidWYocGFzc3dvcmQpLmNvcHkobG1oKTtcbiAgbG1oLmZpbGwoMHgwMCwgMTYpOyAvLyBudWxsIHBhZCB0byAyMSBieXRlc1xuICB2YXIgbnRoID0gQnVmZmVyLmFsbG9jKDIxKTtcbiAgbnRoYXNoYnVmKHBhc3N3b3JkKS5jb3B5KG50aCk7XG4gIG50aC5maWxsKDB4MDAsIDE2KTsgLy8gbnVsbCBwYWQgdG8gMjEgYnl0ZXNcblxuICB2YXIgbG1yID0gbWFrZVJlc3BvbnNlKGxtaCwgbm9uY2UpO1xuICB2YXIgbnRyID0gbWFrZVJlc3BvbnNlKG50aCwgbm9uY2UpO1xuXG4gIHZhciB1c2VybmFtZWxlbiA9IEJ1ZmZlci5ieXRlTGVuZ3RoKHVzZXJuYW1lLCAndWNzMicpO1xuICB2YXIgaG9zdG5hbWVsZW4gPSBCdWZmZXIuYnl0ZUxlbmd0aChob3N0bmFtZSwgJ3VjczInKTtcbiAgdmFyIG50ZG9tYWlubGVuID0gQnVmZmVyLmJ5dGVMZW5ndGgobnRkb21haW4sICd1Y3MyJyk7XG4gIHZhciBsbXJsZW4gPSAweDE4O1xuICB2YXIgbnRybGVuID0gMHgxODtcblxuICB2YXIgbnRkb21haW5vZmYgPSAweDQwO1xuICB2YXIgdXNlcm5hbWVvZmYgPSBudGRvbWFpbm9mZiArIG50ZG9tYWlubGVuO1xuICB2YXIgaG9zdG5hbWVvZmYgPSB1c2VybmFtZW9mZiArIHVzZXJuYW1lbGVuO1xuICB2YXIgbG1yb2ZmID0gaG9zdG5hbWVvZmYgKyBob3N0bmFtZWxlbjtcbiAgdmFyIG50cm9mZiA9IGxtcm9mZiArIGxtcmxlbjtcblxuICB2YXIgcG9zID0gMDtcbiAgdmFyIG1zZ19sZW4gPSA2NCArIG50ZG9tYWlubGVuICsgdXNlcm5hbWVsZW4gKyBob3N0bmFtZWxlbiArIGxtcmxlbiArIG50cmxlbjtcbiAgdmFyIGJ1ZiA9IEJ1ZmZlci5hbGxvYyhtc2dfbGVuKTtcblxuICBidWYud3JpdGUoJ05UTE1TU1AnLCBwb3MsIDcsICdhc2NpaScpOyAvLyBieXRlIHByb3RvY29sWzhdO1xuICBwb3MgKz0gNztcbiAgYnVmLndyaXRlVUludDgoMCwgcG9zKTtcbiAgcG9zKys7XG5cbiAgYnVmLndyaXRlVUludDgoMHgwMywgcG9zKTsgLy8gYnl0ZSB0eXBlO1xuICBwb3MrKztcblxuICBidWYuZmlsbCgweDAwLCBwb3MsIHBvcyArIDMpOyAvLyBieXRlIHplcm9bM107XG4gIHBvcyArPSAzO1xuXG4gIGJ1Zi53cml0ZVVJbnQxNkxFKGxtcmxlbiwgcG9zKTsgLy8gc2hvcnQgbG1fcmVzcF9sZW47XG4gIHBvcyArPSAyO1xuICBidWYud3JpdGVVSW50MTZMRShsbXJsZW4sIHBvcyk7IC8vIHNob3J0IGxtX3Jlc3BfbGVuO1xuICBwb3MgKz0gMjtcbiAgYnVmLndyaXRlVUludDE2TEUobG1yb2ZmLCBwb3MpOyAvLyBzaG9ydCBsbV9yZXNwX29mZjtcbiAgcG9zICs9IDI7XG4gIGJ1Zi5maWxsKDB4MDAsIHBvcywgcG9zICsgMik7IC8vIGJ5dGUgemVyb1syXTtcbiAgcG9zICs9IDI7XG5cbiAgYnVmLndyaXRlVUludDE2TEUobnRybGVuLCBwb3MpOyAvLyBzaG9ydCBudF9yZXNwX2xlbjtcbiAgcG9zICs9IDI7XG4gIGJ1Zi53cml0ZVVJbnQxNkxFKG50cmxlbiwgcG9zKTsgLy8gc2hvcnQgbnRfcmVzcF9sZW47XG4gIHBvcyArPSAyO1xuICBidWYud3JpdGVVSW50MTZMRShudHJvZmYsIHBvcyk7IC8vIHNob3J0IG50X3Jlc3Bfb2ZmO1xuICBwb3MgKz0gMjtcbiAgYnVmLmZpbGwoMHgwMCwgcG9zLCBwb3MgKyAyKTsgLy8gYnl0ZSB6ZXJvWzJdO1xuICBwb3MgKz0gMjtcblxuICBidWYud3JpdGVVSW50MTZMRShudGRvbWFpbmxlbiwgcG9zKTsgLy8gc2hvcnQgZG9tX2xlbjtcbiAgcG9zICs9IDI7XG4gIGJ1Zi53cml0ZVVJbnQxNkxFKG50ZG9tYWlubGVuLCBwb3MpOyAvLyBzaG9ydCBkb21fbGVuO1xuICBwb3MgKz0gMjtcbiAgYnVmLndyaXRlVUludDE2TEUobnRkb21haW5vZmYsIHBvcyk7IC8vIHNob3J0IGRvbV9vZmY7XG4gIHBvcyArPSAyO1xuICBidWYuZmlsbCgweDAwLCBwb3MsIHBvcyArIDIpOyAvLyBieXRlIHplcm9bMl07XG4gIHBvcyArPSAyO1xuXG4gIGJ1Zi53cml0ZVVJbnQxNkxFKHVzZXJuYW1lbGVuLCBwb3MpOyAvLyBzaG9ydCB1c2VyX2xlbjtcbiAgcG9zICs9IDI7XG4gIGJ1Zi53cml0ZVVJbnQxNkxFKHVzZXJuYW1lbGVuLCBwb3MpOyAvLyBzaG9ydCB1c2VyX2xlbjtcbiAgcG9zICs9IDI7XG4gIGJ1Zi53cml0ZVVJbnQxNkxFKHVzZXJuYW1lb2ZmLCBwb3MpOyAvLyBzaG9ydCB1c2VyX29mZjtcbiAgcG9zICs9IDI7XG4gIGJ1Zi5maWxsKDB4MDAsIHBvcywgcG9zICsgMik7IC8vIGJ5dGUgemVyb1syXTtcbiAgcG9zICs9IDI7XG5cbiAgYnVmLndyaXRlVUludDE2TEUoaG9zdG5hbWVsZW4sIHBvcyk7IC8vIHNob3J0IGhvc3RfbGVuO1xuICBwb3MgKz0gMjtcbiAgYnVmLndyaXRlVUludDE2TEUoaG9zdG5hbWVsZW4sIHBvcyk7IC8vIHNob3J0IGhvc3RfbGVuO1xuICBwb3MgKz0gMjtcbiAgYnVmLndyaXRlVUludDE2TEUoaG9zdG5hbWVvZmYsIHBvcyk7IC8vIHNob3J0IGhvc3Rfb2ZmO1xuICBwb3MgKz0gMjtcbiAgYnVmLmZpbGwoMHgwMCwgcG9zLCBwb3MgKyA2KTsgLy8gYnl0ZSB6ZXJvWzZdO1xuICBwb3MgKz0gNjtcblxuICBidWYud3JpdGVVSW50MTZMRShtc2dfbGVuLCBwb3MpOyAvLyBzaG9ydCBtc2dfbGVuO1xuICBwb3MgKz0gMjtcbiAgYnVmLmZpbGwoMHgwMCwgcG9zLCBwb3MgKyAyKTsgLy8gYnl0ZSB6ZXJvWzJdO1xuICBwb3MgKz0gMjtcblxuICBidWYud3JpdGVVSW50MTZMRSgweDgyMDEsIHBvcyk7IC8vIHNob3J0IGZsYWdzO1xuICBwb3MgKz0gMjtcbiAgYnVmLmZpbGwoMHgwMCwgcG9zLCBwb3MgKyAyKTsgLy8gYnl0ZSB6ZXJvWzJdO1xuICBwb3MgKz0gMjtcblxuICBidWYud3JpdGUobnRkb21haW4sIG50ZG9tYWlub2ZmLCBudGRvbWFpbmxlbiwgJ3VjczInKTtcbiAgYnVmLndyaXRlKHVzZXJuYW1lLCB1c2VybmFtZW9mZiwgdXNlcm5hbWVsZW4sICd1Y3MyJyk7XG4gIGJ1Zi53cml0ZShob3N0bmFtZSwgaG9zdG5hbWVvZmYsIGhvc3RuYW1lbGVuLCAndWNzMicpO1xuICBsbXIuY29weShidWYsIGxtcm9mZiwgMCwgbG1ybGVuKTtcbiAgbnRyLmNvcHkoYnVmLCBudHJvZmYsIDAsIG50cmxlbik7XG5cbiAgcmV0dXJuIGJ1Zjtcbn1cblxuZnVuY3Rpb24gbWFrZVJlc3BvbnNlKGhhc2gsIG5vbmNlKVxue1xuICB2YXIgb3V0ID0gQnVmZmVyLmFsbG9jKDI0KTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IDM7IGkrKykge1xuICAgIHZhciBrZXlidWYgPSAkLm9kZHBhcigkLmV4cGFuZGtleShoYXNoLnNsaWNlKGkgKiA3LCBpICogNyArIDcpKSk7XG5cbiAgICB2YXIgZGVzID0gZGVzanMuREVTLmNyZWF0ZSh7dHlwZTogJ2VuY3J5cHQnLCBrZXk6IGtleWJ1Zn0pO1xuICAgIHZhciBtYWdpY0tleSA9IEJ1ZmZlci5mcm9tKG5vbmNlLnRvU3RyaW5nKCdiaW5hcnknKSk7XG4gICAgdmFyIGluc2VydEJ1ZmYgPSBCdWZmZXIuZnJvbShkZXMudXBkYXRlKG1hZ2ljS2V5KSk7XG5cbiAgICBvdXQuZmlsbChpbnNlcnRCdWZmLCBpICogOCwgaSAqIDggKyA4LCAnYmluYXJ5Jyk7XG4gICAgXG4gIH1cbiAgcmV0dXJuIG91dDtcbn1cblxuZXhwb3J0cy5lbmNvZGVUeXBlMSA9IGVuY29kZVR5cGUxO1xuZXhwb3J0cy5kZWNvZGVUeXBlMiA9IGRlY29kZVR5cGUyO1xuZXhwb3J0cy5lbmNvZGVUeXBlMyA9IGVuY29kZVR5cGUzO1xuXG4vLyBDb252ZW5pZW5jZSBtZXRob2RzLlxuXG5leHBvcnRzLmNoYWxsZW5nZUhlYWRlciA9IGZ1bmN0aW9uIChob3N0bmFtZSwgZG9tYWluKSB7XG4gIHJldHVybiAnTlRMTSAnICsgZXhwb3J0cy5lbmNvZGVUeXBlMShob3N0bmFtZSwgZG9tYWluKS50b1N0cmluZygnYmFzZTY0Jyk7XG59O1xuXG5leHBvcnRzLnJlc3BvbnNlSGVhZGVyID0gZnVuY3Rpb24gKHJlcywgdXJsLCBkb21haW4sIHVzZXJuYW1lLCBwYXNzd29yZCkge1xuICB2YXIgc2VydmVyTm9uY2UgPSBCdWZmZXIuZnJvbSgocmVzLmhlYWRlcnNbJ3d3dy1hdXRoZW50aWNhdGUnXS5tYXRjaCgvXk5UTE1cXHMrKC4rPykoLHxcXHMrfCQpLykgfHwgW10pWzFdLCAnYmFzZTY0Jyk7XG4gIHZhciBob3N0bmFtZSA9IHJlcXVpcmUoJ3VybCcpLnBhcnNlKHVybCkuaG9zdG5hbWU7XG4gIHJldHVybiAnTlRMTSAnICsgZXhwb3J0cy5lbmNvZGVUeXBlMyh1c2VybmFtZSwgaG9zdG5hbWUsIGRvbWFpbiwgZXhwb3J0cy5kZWNvZGVUeXBlMihzZXJ2ZXJOb25jZSksIHBhc3N3b3JkKS50b1N0cmluZygnYmFzZTY0Jylcbn07XG5cbi8vIEltcG9ydCBzbWJoYXNoIG1vZHVsZS5cblxuZXhwb3J0cy5zbWJoYXNoID0gcmVxdWlyZSgnLi9zbWJoYXNoJyk7XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/typed-rest-client/opensource/Node-SMB/lib/ntlm.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/typed-rest-client/opensource/Node-SMB/lib/smbhash.js":
/*!***************************************************************************!*\
  !*** ./node_modules/typed-rest-client/opensource/Node-SMB/lib/smbhash.js ***!
  \***************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("var $ = __webpack_require__(/*! ./common */ \"(rsc)/./node_modules/typed-rest-client/opensource/Node-SMB/lib/common.js\");\n\nvar jsmd4 = __webpack_require__(/*! js-md4 */ \"(rsc)/./node_modules/js-md4/src/md4.js\");\nvar desjs = __webpack_require__(/*! des.js */ \"(rsc)/./node_modules/des.js/lib/des.js\");\n\n/*\n * Generate the LM Hash\n */\nfunction lmhashbuf(inputstr)\n{\n  /* ASCII --> uppercase */\n  var x = inputstr.substring(0, 14).toUpperCase();\n  var xl = Buffer.byteLength(x, 'ascii');\n\n  /* null pad to 14 bytes */\n  var y = Buffer.alloc(14);\n  y.write(x, 0, xl, 'ascii');\n  y.fill(0, xl);\n\n  /* insert odd parity bits in key */\n  var halves = [\n    $.oddpar($.expandkey(y.slice(0, 7))),\n    $.oddpar($.expandkey(y.slice(7, 14)))\n  ];\n\n  /* DES encrypt magic number \"KGS!@#$%\" to two\n   * 8-byte ciphertexts, (ECB, no padding)\n   */\n  var buf = Buffer.alloc(16);\n  var pos = 0;\n  var cts = halves.forEach(function(z) {\n    var des = desjs.DES.create({type: 'encrypt', key: z});\n    var magicKey = Buffer.from('KGS!@#$%', 'ascii');\n    var insertBuff = Buffer.from(des.update(magicKey));\n    buf.fill(insertBuff, pos, pos + 8, 'binary');\n    pos += 8;\n  });\n\n  /* concat the two ciphertexts to form 16byte value,\n   * the LM hash */\n  return buf;\n}\n\nfunction nthashbuf(str)\n{\n  /* take MD4 hash of UCS-2 encoded password */\n  var ucs2 = Buffer.from(str, 'ucs2');\n  var md4 = jsmd4.create();\n  md4.update(ucs2);\n  return Buffer.from(md4.digest('binary'), 'binary');\n}\n\nfunction lmhash(is)\n{\n  return $.bintohex(lmhashbuf(is));\n}\n\nfunction nthash(is)\n{\n  return $.bintohex(nthashbuf(is));\n}\n\nmodule.exports.nthashbuf = nthashbuf;\nmodule.exports.lmhashbuf = lmhashbuf;\n\nmodule.exports.nthash = nthash;\nmodule.exports.lmhash = lmhash;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvdHlwZWQtcmVzdC1jbGllbnQvb3BlbnNvdXJjZS9Ob2RlLVNNQi9saWIvc21iaGFzaC5qcyIsIm1hcHBpbmdzIjoiQUFBQSxRQUFRLG1CQUFPLENBQUMsMEZBQVU7O0FBRTFCLFlBQVksbUJBQU8sQ0FBQyxzREFBUTtBQUM1QixZQUFZLG1CQUFPLENBQUMsc0RBQVE7O0FBRTVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0Msd0JBQXdCO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHdCQUF3QjtBQUN4Qix3QkFBd0I7O0FBRXhCLHFCQUFxQjtBQUNyQixxQkFBcUIiLCJzb3VyY2VzIjpbIkM6XFxQcm9qZWN0c1xcQnVpbGRMYXVuY2hlclRlc3RcXG5vZGVfbW9kdWxlc1xcdHlwZWQtcmVzdC1jbGllbnRcXG9wZW5zb3VyY2VcXE5vZGUtU01CXFxsaWJcXHNtYmhhc2guanMiXSwic291cmNlc0NvbnRlbnQiOlsidmFyICQgPSByZXF1aXJlKCcuL2NvbW1vbicpO1xuXG52YXIganNtZDQgPSByZXF1aXJlKFwianMtbWQ0XCIpO1xudmFyIGRlc2pzID0gcmVxdWlyZShcImRlcy5qc1wiKTtcblxuLypcbiAqIEdlbmVyYXRlIHRoZSBMTSBIYXNoXG4gKi9cbmZ1bmN0aW9uIGxtaGFzaGJ1ZihpbnB1dHN0cilcbntcbiAgLyogQVNDSUkgLS0+IHVwcGVyY2FzZSAqL1xuICB2YXIgeCA9IGlucHV0c3RyLnN1YnN0cmluZygwLCAxNCkudG9VcHBlckNhc2UoKTtcbiAgdmFyIHhsID0gQnVmZmVyLmJ5dGVMZW5ndGgoeCwgJ2FzY2lpJyk7XG5cbiAgLyogbnVsbCBwYWQgdG8gMTQgYnl0ZXMgKi9cbiAgdmFyIHkgPSBCdWZmZXIuYWxsb2MoMTQpO1xuICB5LndyaXRlKHgsIDAsIHhsLCAnYXNjaWknKTtcbiAgeS5maWxsKDAsIHhsKTtcblxuICAvKiBpbnNlcnQgb2RkIHBhcml0eSBiaXRzIGluIGtleSAqL1xuICB2YXIgaGFsdmVzID0gW1xuICAgICQub2RkcGFyKCQuZXhwYW5ka2V5KHkuc2xpY2UoMCwgNykpKSxcbiAgICAkLm9kZHBhcigkLmV4cGFuZGtleSh5LnNsaWNlKDcsIDE0KSkpXG4gIF07XG5cbiAgLyogREVTIGVuY3J5cHQgbWFnaWMgbnVtYmVyIFwiS0dTIUAjJCVcIiB0byB0d29cbiAgICogOC1ieXRlIGNpcGhlcnRleHRzLCAoRUNCLCBubyBwYWRkaW5nKVxuICAgKi9cbiAgdmFyIGJ1ZiA9IEJ1ZmZlci5hbGxvYygxNik7XG4gIHZhciBwb3MgPSAwO1xuICB2YXIgY3RzID0gaGFsdmVzLmZvckVhY2goZnVuY3Rpb24oeikge1xuICAgIHZhciBkZXMgPSBkZXNqcy5ERVMuY3JlYXRlKHt0eXBlOiAnZW5jcnlwdCcsIGtleTogen0pO1xuICAgIHZhciBtYWdpY0tleSA9IEJ1ZmZlci5mcm9tKCdLR1MhQCMkJScsICdhc2NpaScpO1xuICAgIHZhciBpbnNlcnRCdWZmID0gQnVmZmVyLmZyb20oZGVzLnVwZGF0ZShtYWdpY0tleSkpO1xuICAgIGJ1Zi5maWxsKGluc2VydEJ1ZmYsIHBvcywgcG9zICsgOCwgJ2JpbmFyeScpO1xuICAgIHBvcyArPSA4O1xuICB9KTtcblxuICAvKiBjb25jYXQgdGhlIHR3byBjaXBoZXJ0ZXh0cyB0byBmb3JtIDE2Ynl0ZSB2YWx1ZSxcbiAgICogdGhlIExNIGhhc2ggKi9cbiAgcmV0dXJuIGJ1Zjtcbn1cblxuZnVuY3Rpb24gbnRoYXNoYnVmKHN0cilcbntcbiAgLyogdGFrZSBNRDQgaGFzaCBvZiBVQ1MtMiBlbmNvZGVkIHBhc3N3b3JkICovXG4gIHZhciB1Y3MyID0gQnVmZmVyLmZyb20oc3RyLCAndWNzMicpO1xuICB2YXIgbWQ0ID0ganNtZDQuY3JlYXRlKCk7XG4gIG1kNC51cGRhdGUodWNzMik7XG4gIHJldHVybiBCdWZmZXIuZnJvbShtZDQuZGlnZXN0KCdiaW5hcnknKSwgJ2JpbmFyeScpO1xufVxuXG5mdW5jdGlvbiBsbWhhc2goaXMpXG57XG4gIHJldHVybiAkLmJpbnRvaGV4KGxtaGFzaGJ1ZihpcykpO1xufVxuXG5mdW5jdGlvbiBudGhhc2goaXMpXG57XG4gIHJldHVybiAkLmJpbnRvaGV4KG50aGFzaGJ1ZihpcykpO1xufVxuXG5tb2R1bGUuZXhwb3J0cy5udGhhc2hidWYgPSBudGhhc2hidWY7XG5tb2R1bGUuZXhwb3J0cy5sbWhhc2hidWYgPSBsbWhhc2hidWY7XG5cbm1vZHVsZS5leHBvcnRzLm50aGFzaCA9IG50aGFzaDtcbm1vZHVsZS5leHBvcnRzLmxtaGFzaCA9IGxtaGFzaDtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/typed-rest-client/opensource/Node-SMB/lib/smbhash.js\n");

/***/ })

};
;